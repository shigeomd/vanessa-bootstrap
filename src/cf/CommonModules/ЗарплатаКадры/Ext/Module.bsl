
#Область ПрограммныйИнтерфейс

// Выполняет действия в форме Организации, связанные с зарплатно-кадровой спецификой.
// Вызов процедуры необходимо выполнять в обработчике ПриСозданииНаСервере
// формы организации.
Процедура ОрганизацииФормаЭлементаПриСозданииНаСервере(Форма) Экспорт
	
	Если Форма.Параметры.Ключ.Пустая() Тогда
		РедактированиеПериодическихСведений.ИнициализироватьЗаписьДляРедактированияВФорме(Форма, "ИсторияРегистрацийВОрганеПФР", Форма.ОрганизацияСсылка);
		РедактированиеПериодическихСведений.ИнициализироватьЗаписьДляРедактированияВФорме(Форма, "ТерриториальныеУсловияПФР", Форма.ОрганизацияСсылка);
	КонецЕсли;
	
	Форма.УстановитьПараметрыФункциональныхОпцийФормы(Новый Структура("Организация", Форма.Объект.Ссылка));
	
КонецПроцедуры

// Выполняет действия в форме Организации, связанные с зарплатно-кадровой спецификой.
// Вызов процедуры необходимо выполнять в обработчике ПриЧтенииНаСервере
// формы организации.
Процедура ОрганизацииФормаЭлементаПриЧтенииНаСервере(Форма) Экспорт
	
	ПрочитатьПериодическиеСведенияОрганизации(Форма);
	
КонецПроцедуры

// Выполняет действия в форме Организации, связанные с зарплатно-кадровой спецификой.
// Вызов процедуры необходимо выполнять в обработчике ПередЗаписьюНаСервере
// формы организации.
Процедура ОрганизацииФормаЭлементаПередЗаписьюНаСервере(Форма) Экспорт
	
	ЗаписатьПериодическиеСведенияОрганизации(Форма);
	
КонецПроцедуры

// Выполняет действия в форме Организации, связанные с зарплатно-кадровой спецификой.
// Вызов процедуры необходимо выполнять в обработчике ПослеЗаписиНаСервере
// формы организации.
Процедура ОрганизацииФормаЭлементаПослеЗаписиНаСервере(Форма) Экспорт
	
	ПрочитатьПериодическиеСведенияОрганизации(Форма);
	
	ОбновитьПовторноИспользуемыеЗначения();
	
КонецПроцедуры

// Выполняет действия в форме Организации, связанные с зарплатно-кадровой спецификой.
// Вызов процедуры необходимо выполнять в обработчике ОбработкаПроверкиЗаполненияНаСервере
// формы организации.
Процедура ОрганизацииФормаЭлементаОбработкаПроверкиЗаполненияНаСервере(Форма, Отказ) Экспорт
	
	РедактированиеПериодическихСведений.ПроверитьЗаписьВФорме(Форма, "ИсторияРегистрацийВОрганеПФР", Форма.ОрганизацияСсылка, Отказ);
	РедактированиеПериодическихСведений.ПроверитьЗаписьВФорме(Форма, "ТерриториальныеУсловияПФР", Форма.ОрганизацияСсылка, Отказ);
	
КонецПроцедуры

// Процедура регистрирует факт оплаты ведомостей.
//
// Параметры:
//		ПлатежныйДокумент	- платежный документ (документ-объект).
//		Организация			- организация документа.
//		Ведомости			- массив ссылок на ведомости (типа ДокументСсылка.ВедомостьНаВыплатуЗарплатыВКассу,
//								ДокументСсылка.ВедомостьНаВыплатуЗарплатыВБанк).
//		ФизическиеЛица		- массив ссылок на физические лица.
//		Оплаченные			- булево; описывает учет статуса оплаты:
//								истина		- только оплаченные
//								ложь		- неоплаченные
//								неопределено- состояние оплаты не учитывается.
//		Отказ				- признак отказа выполнения операции.
//
// Обработка ошибочных ситуаций
//	выдается сообщение, признак «Отказ» выставляется в Истина.
//
Процедура ЗарегистрироватьОплатуВедомостей(ПлатежныйДокумент, Организация, Ведомости, ФизическиеЛица = Неопределено, Оплаченные = Ложь, Отказ = Ложь) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	
	ВзаиморасчетыССотрудниками.СоздатьВТДанныеВедомостейДляОплатыДокументом(Запрос.МенеджерВременныхТаблиц, Истина, ПлатежныйДокумент.Ссылка, Ведомости, ФизическиеЛица, Оплаченные);
	
	Запрос.Текст =
	"ВЫБРАТЬ
	|	ОплачиваемыеДанныеВедомостей.Ведомость,
	|	ОплачиваемыеДанныеВедомостей.ФизическоеЛицо
	|ИЗ
	|	ВТДанныеВедомостейДляОплатыДокументом КАК ОплачиваемыеДанныеВедомостей
	|
	|СГРУППИРОВАТЬ ПО
	|	ОплачиваемыеДанныеВедомостей.Ведомость,
	|	ОплачиваемыеДанныеВедомостей.ФизическоеЛицо";
	
	ОплатаВедомостей = Запрос.Выполнить().Выгрузить();
	
	ВзаиморасчетыССотрудниками.ЗарегистрироватьОплатуВедомостейДокументом(ПлатежныйДокумент, Отказ, ОплатаВедомостей);
	
	Если НЕ Отказ Тогда
		
		Запрос.Текст =
		"ВЫБРАТЬ
		|	МАКСИМУМ(ОплачиваемыеДанныеВедомостей.Ведомость.ПериодРегистрации) КАК ПериодРегистрации,
		|	ОплачиваемыеДанныеВедомостей.ФизическоеЛицо
		|ПОМЕСТИТЬ ВТПериодыРегистрации
		|ИЗ
		|	ВТДанныеВедомостейДляОплатыДокументом КАК ОплачиваемыеДанныеВедомостей
		|
		|СГРУППИРОВАТЬ ПО
		|	ОплачиваемыеДанныеВедомостей.ФизическоеЛицо
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|ВЫБРАТЬ РАЗЛИЧНЫЕ
		|	ПериодыРегистрации.ПериодРегистрации
		|ИЗ
		|	ВТПериодыРегистрации КАК ПериодыРегистрации";
		
		Выборка = Запрос.Выполнить().Выбрать();	
		Пока Выборка.Следующий() Цикл  // почти всегда в цикле будет одна итерация
			
			Запрос.УстановитьПараметр("ПериодРегистрации", Выборка.ПериодРегистрации);	
			Запрос.Текст =
			"ВЫБРАТЬ
			|	ОплачиваемыеДанныеВедомостей.ФизическоеЛицо
			|ПОМЕСТИТЬ ВТСписокФизлицПериодаРегистрации
			|ИЗ
			|	ВТДанныеВедомостейДляОплатыДокументом КАК ОплачиваемыеДанныеВедомостей
			|ГДЕ
			|	ОплачиваемыеДанныеВедомостей.Ведомость.ПериодРегистрации = &ПериодРегистрации
			|;
			|
			|////////////////////////////////////////////////////////////////////////////////
			|ВЫБРАТЬ
			|	ОплачиваемыеДанныеВедомостей.ФизическоеЛицо,
			|	ОплачиваемыеДанныеВедомостей.СуммаКВыплате КАК СуммаВыплаты
			|ПОМЕСТИТЬ ВТСписокСотрудников
			|ИЗ
			|	ВТДанныеВедомостейДляОплатыДокументом КАК ОплачиваемыеДанныеВедомостей
			|ГДЕ
			|	ОплачиваемыеДанныеВедомостей.ФизическоеЛицо В
			|			(ВЫБРАТЬ
			|				СписокФизлиц.ФизическоеЛицо
			|			ИЗ
			|				ВТСписокФизлицПериодаРегистрации КАК СписокФизлиц)
			|;
			|
			|////////////////////////////////////////////////////////////////////////////////
			|УНИЧТОЖИТЬ ВТСписокФизлицПериодаРегистрации";
			Запрос.Выполнить();
			
			УчетНДФЛ.РассчитатьИЗарегистрироватьУдержанныеНалоги(ПлатежныйДокумент.Ссылка, ПлатежныйДокумент.Движения, Отказ, Организация,
				ПлатежныйДокумент.Дата, Запрос.МенеджерВременныхТаблиц, Ложь, Выборка.ПериодРегистрации);
			
			Запрос.Текст = "УНИЧТОЖИТЬ ВТСписокСотрудников";
			Запрос.Выполнить();
			
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Выполняет формирование таблицы с набором значений доступа объекта (документа), 
// содержащего ссылки на организацию и сотрудника (сотрудников).
// Вызывается из процедуры ЗаполнитьНаборыЗначенийДоступа, реализованной в модуле таких 
// документов, доступ к которым выполняется через наборы значений доступа.
// Параметры:
//		Объект
//		Таблица - переданная таблица значений.
//		ПутьОрганизация - строка с именем реквизита, содержащего организацию.
//		ПутьСотрудник - строка с именем реквизита, содержащего сотрудника.
//			Может быть идентификатором реквизита объекта (например, "Сотрудник") или
//			путем к реквизиту табличной части в 
//			формате <ИмяТабличнойЧасти>.<ИмяРеквизита> 
//			(например, "Начисления.Сотрудник")
//
Процедура ЗаполнитьНаборыПоОрганизацииИСотрудникам(Объект, Таблица, ПутьОрганизация, ПутьСотрудник) Экспорт
	
	// Логика ограничения:
	// объект доступен, если доступна организация и все физические лица
	
	СтрокаТаб = Таблица.Добавить();
	СтрокаТаб.ЗначениеДоступа = Объект[ПутьОрганизация];
	
	СтрокиПутиСотрудника = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьСотрудник, ".");
	Если СтрокиПутиСотрудника.Количество() = 1 Тогда
		СтрокаТаб = Таблица.Добавить();
		СтрокаТаб.ЗначениеДоступа = ОбщегоНазначения.ЗначениеРеквизитаОбъекта(Объект[ПутьСотрудник], "ФизическоеЛицо");
		
	Иначе
		Сотрудники = Новый Массив;
		Для Каждого СтрокаТаблицы Из Объект[СтрокиПутиСотрудника[0]] Цикл
			Сотрудники.Добавить(СтрокаТаблицы[СтрокиПутиСотрудника[1]]);
		КонецЦикла;
		// Получим значения физлиц
		ФизлицаСотрудников = ОбщегоНазначения.ЗначениеРеквизитаОбъектов(Сотрудники, "ФизическоеЛицо");
		МассивФизлицСотрудников = ОбщегоНазначения.ВыгрузитьКолонку(ФизлицаСотрудников, "Значение", Истина);
		
		Для Каждого ФизическоеЛицо Из МассивФизлицСотрудников Цикл
			СтрокаТаб = Таблица.Добавить();
			СтрокаТаб.ЗначениеДоступа = ФизическоеЛицо;
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Заполняет массив типов неразделенных данных, для которых поддерживается сопоставление ссылок
// при загрузке данных в другую информационную базу.
//
// Параметры:
//  Типы - Массив(ОбъектМетаданных)
//
Процедура ПриЗаполненииТиповОбщихДанныхПоддерживающихСопоставлениеСсылокПриЗагрузке(Типы) Экспорт
	ЗарплатаКадрыВнутренний.ПриЗаполненииТиповОбщихДанныхПоддерживающихСопоставлениеСсылокПриЗагрузке(Типы);
КонецПроцедуры

// Заполняет массив типов неразделенных данных, для которых не требуется сопоставление ссылок
// при загрузке данных в другую информационную базу, т.к. корректное сопоставление ссылок
// гарантируется с помощью других механизмов.
//
// Параметры:
//  Типы - Массив(ОбъектМетаданных)
//
Процедура ПриЗаполненииТиповОбщихДанныхНеТребующихСопоставлениеСсылокПриЗагрузке(Типы) Экспорт
	ЗарплатаКадрыВнутренний.ПриЗаполненииТиповОбщихДанныхНеТребующихСопоставлениеСсылокПриЗагрузке(Типы);
КонецПроцедуры

// Функция возвращает сведения о сотрудниках (застрахованных в ПФР), работавших в организации в указанном отчетном
// периоде.
//
// Параметры:
//  Организация - СправочникСсылка.Организации, организация (головная, 
//				либо обособленное подразделение с выделенным балансом) 
//				по которой требуется получить сведения.
//  ОтчетныйПериод - дата, определяет отчетный период ПФР (квартал).
//
// Возвращаемое значение:
//  ТаблицаЗначений с колонками "Фамилия", "Имя", "Отчество" и "СтраховойНомерПФР", в которых
//  содержится информация о фамилии, имени, отчестве и страховом номере (СНИЛС) каждого
//  из сотрудников (застрахованных лиц) организации соответственно.
//
Функция СписокЗастрахованныхЛицОрганизацииЗаОтчетныйПериодПФР(Организация, ОтчетныйПериод) Экспорт 

  НачалоПериода = ПерсонифицированныйУчетКлиентСервер.ПолучитьНачалоОтчетногоПериода(ОтчетныйПериод);
  ОкончаниеПериода = ПерсонифицированныйУчетКлиентСервер.ОкончаниеОтчетногоПериодаПерсУчета(ОтчетныйПериод);
  
  Возврат УчетСтраховыхВзносов.СписокЗастрахованныхЛицОрганизации(Организация, НачалоПериода, ОкончаниеПериода);
  
КонецФункции

// Возвращает ссылку на "Регистрацию в налоговом органе" по состоянию на некоторую ДатаАктуальности.
//
// Параметры:
//		СтруктурнаяЕдиница	- организация или подразделение.
//		ДатаАктуальности	- дата, на которую берется регистрация в налоговом органе.
//
//	Возвращаемое значение:
//		СправочникСсылка.РегистрацииВНалоговомОргане
//
Функция РегистрацияВНалоговомОргане(СтруктурнаяЕдиница, Знач ДатаАктуальности = Неопределено) Экспорт
	Возврат ЗарплатаКадрыПовтИсп.РегистрацияВНалоговомОргане(СтруктурнаяЕдиница, ДатаАктуальности)
КонецФункции

// Процедура переопределяет свойства объекта, с которыми он будет отображен в форме Отчетность.
// Параметры:
//  СвойстваОбъектов  - ТаблицаЗначений - (см. РегламентированнаяОтчетностьПереопределяемый.ОпределитьСвойстваОбъектовДляОтображенииВФормеОтчетность)
//
Процедура ОпределитьСвойстваОбъектовДляОтображенииВФормеОтчетность(СвойстваОбъектов) Экспорт
	ЗарплатаКадрыВнутренний.ОпределитьСвойстваОбъектовДляОтображенииВФормеОтчетность(СвойстваОбъектов);	
КонецПроцедуры

// Определяет свойства, касающиеся общих свойств объектов конфигураций-потребителей для отображения в форме Отчетность
// и возможности создания новый объектов из формы Отчетность.
//
// Параметры:
//  ТаблицаОписания  - ТаблицаЗначений -  (см. РегламентированнаяОтчетностьПереопределяемый.ОпределитьТаблицуОписанияОбъектовРегламентированнойОтчетности)
//		
Процедура ОпределитьТаблицуОписанияОбъектовРегламентированнойОтчетности(ТаблицаОписания) Экспорт
	ЗарплатаКадрыВнутренний.ОпределитьТаблицуОписанияОбъектовРегламентированнойОтчетности(ТаблицаОписания);	
КонецПроцедуры

// Процедура переопределяет обработчик подписки на событие "ЗаписьОбъектовРегламентированнойОтчетности*".
//
// Параметры: - (см. РегламентированнаяОтчетностьПереопределяемый.ЗаписьОбъектовРегламентированнойОтчетности).
//
Процедура ЗаписьОбъектовРегламентированнойОтчетности(Ссылка, Отказ, СтандартнаяОбработка) Экспорт
	ПерсонифицированныйУчет.ЗаписьОбъектовРегламентированнойОтчетности(Ссылка, Отказ, СтандартнаяОбработка);
	ЗарплатаКадрыВнутренний.ЗаписьОбъектовРегламентированнойОтчетности(Ссылка, Отказ, СтандартнаяОбработка);
КонецПроцедуры

// Функция возвращает значение настройки использования учета по статьям финансирования.
//
//	Возвращаемое значение:
//		Булево
//
Функция ИспользоватьСтатьиФинансированияЗарплата() Экспорт

	УстановитьПривилегированныйРежим(Истина);
	Возврат Константы.ИспользоватьСтатьиФинансированияЗарплата.Получить();

КонецФункции

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Выполняет начальное заполнение классификаторов, и наборов записей регистров сведений.
// Если не указывать входной параметр, будет произведено начальное заполнение всех
// известных справочников - классификаторов и регистров сведений.
//
// Параметры:
//		ПараметрыВосстановления 	- Структура,
//										*ИменаОбъектовМетаданных -  Строка, строка полных имен объектов метаданных
//											разделенных, запятыми (см. процедуру ЗарплатаКадрыВнутренний.УстановитьНачальныеЗначения).
//		АдресРезультатаВХранилище 	- параметр необходимый для процедуры вызываемой в качестве фонового задания.
//
Процедура УстановитьНачальныеЗначения(ПараметрыВосстановления, АдресРезультатаВХранилище) Экспорт
	
	ИменаОбъектовМетаданных = "";
	Если ПараметрыВосстановления.Свойство("ИменаОбъектовМетаданных") И НЕ ПустаяСтрока(ПараметрыВосстановления.ИменаОбъектовМетаданных) Тогда
		ИменаОбъектовМетаданных = ПараметрыВосстановления.ИменаОбъектовМетаданных;
	КонецЕсли; 
	
	ЗарплатаКадрыВнутренний.УстановитьНачальныеЗначения(ИменаОбъектовМетаданных);
	
КонецПроцедуры


// Выполняет пропорциональное распределение суммы в соответствии
// с заданными базовыми значениями. 
//
// Параметры:
//  РаспределяемаяСумма - Число - сумма, которую надо распределить;
//  МассивБазовыхЗначений - базовые значения;
//  Точность - Число - точность округления при распределении. Необязателен.
//  КоэффициентЗависимостиОтБазы - коэффициент характерный для соотношения распределяемого и базового значения. 
//  Положительное число в диапазоне  0 < КоэффициентЗависимостиОтБазы <= 1
//
// Предназначена для распределения сумм тем или иным образом "привязанных" к некоторым базовым значениям. 
// Примеры: распределение удержания по начислениям, распределение выплаты по остаткам. 
// Распределение выполняется с ограничением результата распределения величиной: 
// элемент из МассивБазовыхЗначений * КоэффициентЗависимостиОтБазы
// Нераспределенная часть суммы относится к максимальному значению из МассивБазовыхЗначений
//
// Аналог: ОбщегоНазначения.РаспределитьСуммуПропорциональноКоэффициентам
// В отличие от аналога 
// - не допускает результатов распределения, "завышенных" относительно базовых 
//   значений (исключение - максимальное базовое значение)
// - не допускает отнесение положительных сумм к отрицательным базовым значениям и 
//   наоборот (исключение - максимальное базовое значение)
// - относит избыток распределяемой суммы к максимальному базовому значению, а 
//   не к максимальному по модулю значению
//
// Возвращаемое значение:
//  Массив - массив размерностью равный массиву базовых значений, содержит
//           суммы в соответствии с весом базового значения в массиве всех базовых значений.
//           В случае если распределить не удалось (РаспределяемаяСумма = 0, кол-во базовых значений = 0,
//           или сумма базовых значений = 0), возвращается значение НеОпределено
//
Функция РаспределитьСуммуПропорциональноБазе(Знач РаспределяемаяСумма, МассивБазовыхЗначений, Знач Точность = 2, КоэффициентЗависимостиОтБазы = 1, ВычетИзБазы = 0) Экспорт
	
	Если МассивБазовыхЗначений.Количество() = 0 Или Не ЗначениеЗаполнено(РаспределяемаяСумма) Тогда
		Возврат НеОпределено;
	КонецЕсли;
	
	ИндексМаксимальногоБазовогоЗначения = 0;
	МаксимальнаяБаза = 0;
	РаспределеннаяСумма = 0;
	СуммаБазы = 0;
	
	Для Индекс = 0 По МассивБазовыхЗначений.Количество() - 1 Цикл
		БазовоеЗначение = МассивБазовыхЗначений[Индекс];
		Если МаксимальнаяБаза < БазовоеЗначение Тогда
			МаксимальнаяБаза = БазовоеЗначение;
			ИндексМаксимальногоБазовогоЗначения = Индекс;
		КонецЕсли;
		// Сумма всех значений для распределения 
		СуммаБазы = СуммаБазы + ?(БазовоеЗначение > 0, БазовоеЗначение, -БазовоеЗначение);
	КонецЦикла;
	
	Если СуммаБазы = 0 Тогда
		Возврат НеОпределено;
	КонецЕсли;
	
	// ЭффективныйКоэффициентЗависимостиОтБазы распределяемой суммы к базовой сумме всегда должен быть положительнымЕсли распределяемая сумма и база разных знаков - нужно 
	// изменить знак результата, чтобы положительные суммы не относились к отрицательным базам
	Если РаспределяемаяСумма * СуммаБазы > 0 Тогда
		ЭффективныйКоэффициентЗависимостиОтБазы = РаспределяемаяСумма / СуммаБазы;
	Иначе
		ЭффективныйКоэффициентЗависимостиОтБазы = - РаспределяемаяСумма / СуммаБазы;
	КонецЕсли;
	ЭффективныйКоэффициентЗависимостиОтБазы = Мин(ЭффективныйКоэффициентЗависимостиОтБазы, КоэффициентЗависимостиОтБазы);
	
	Результат = Новый Массив(МассивБазовыхЗначений.Количество());
	
	Для Индекс = 0 По МассивБазовыхЗначений.Количество() - 1 Цикл
		Результат[Индекс] = Окр(ЭффективныйКоэффициентЗависимостиОтБазы * МассивБазовыхЗначений[Индекс], Точность, 1);
		РаспределеннаяСумма = РаспределеннаяСумма + Результат[Индекс];
	КонецЦикла;
	
	// Погрешности округления отнесем на максимальную базовую сумму
	Если Не РаспределеннаяСумма = РаспределяемаяСумма Тогда
		Результат[ИндексМаксимальногоБазовогоЗначения] = Результат[ИндексМаксимальногоБазовогоЗначения] + РаспределяемаяСумма - РаспределеннаяСумма;
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

#Область ЗаполнениеЗначенийПоУмолчанию

// Выполняет заполнение первоначальных значений при создании новых 
// объектов или открытии иных форм.
// Параметры:
//		Форма - форма, реквизиты которой необходимо заполнить.
//		ЗапрашиваемыеЗначения - структура с запрашиваемыми значениями.
//			Имя элемента структуры идентифицирует значение, которое 
//				необходимо заполнить.
//			Значение элемента структуры - путь к реквизиту формы, значение
//				которого необходимо заполнить.
//			Список поддерживаемых значений см. в описании ПолучитьЗначенияПоУмолчанию.
//
Процедура ЗаполнитьПервоначальныеЗначенияВФорме(Форма, ЗапрашиваемыеЗначения) Экспорт
	
	ФиксированныеЗначения = Новый Массив;
	Для Каждого ЗапрашиваемоеЗначение Из ЗапрашиваемыеЗначения Цикл
		Если ЗначениеЗаполнено(ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, ЗапрашиваемоеЗначение.Значение)) Тогда
			ФиксированныеЗначения.Добавить(ЗапрашиваемоеЗначение.Ключ)
		КонецЕсли	
	КонецЦикла;

	ЗаполнитьЗначенияВФорме(Форма, ЗапрашиваемыеЗначения, ФиксированныеЗначения);
	
КонецПроцедуры

// Выполняет заполнение значений в форме на основании значений по умолчанию.
// 
// Параметры:
//		Форма - форма, реквизиты которой необходимо заполнить.
//		ЗапрашиваемыеЗначения - структура с запрашиваемыми значениями.
//			Имя элемента структуры идентифицирует значение, которое 
//				необходимо заполнить.
//			Значение элемента структуры - путь к реквизиту формы, значение
//				которого необходимо заполнить.
//			Список поддерживаемых значений см. в описании ПолучитьЗначенияПоУмолчанию.
//
//		ФиксированныеЗначения - (необязательный) массив, 
//				Содержит идентификаторы значений, 
//				которое не должны быть изменены при заполнении.
//
Процедура ЗаполнитьЗначенияВФорме(Форма, ЗапрашиваемыеЗначения, ФиксированныеЗначения = Неопределено) Экспорт
	
	Если ФиксированныеЗначения = Неопределено Тогда
		ФиксированныеЗначения = Новый Массив
	КонецЕсли;
		
	ЗаполняемыеЗначения = Новый Структура;
	
	Для Каждого ЗапрашиваемоеЗначение Из ЗапрашиваемыеЗначения Цикл
		
		ЗначениеРеквизита = ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, ЗапрашиваемоеЗначение.Значение);
		
		Если ФиксированныеЗначения.Найти(ЗапрашиваемоеЗначение.Ключ) = Неопределено Тогда
			ЗначениеРеквизита = ПустоеЗначениеТипаПоЗначению(ЗначениеРеквизита);
		КонецЕсли;	
		
		ЗаполняемыеЗначения.Вставить(ЗапрашиваемоеЗначение.Ключ, ЗначениеРеквизита);
		
	КонецЦикла;
	
	ПолучитьЗначенияПоУмолчанию(ЗаполняемыеЗначения);
	
	// Заполняем значения
	Для Каждого ЗапрашиваемоеЗначение Из ЗапрашиваемыеЗначения Цикл
		Если ФиксированныеЗначения.Найти(ЗапрашиваемоеЗначение.Ключ) = Неопределено Тогда
			ЗначениеРеквизита = НеОпределено;
			Если ЗаполняемыеЗначения.Свойство(ЗапрашиваемоеЗначение.Ключ, ЗначениеРеквизита) Тогда 
				ОбщегоНазначенияКлиентСервер.УстановитьРеквизитФормыПоПути(Форма, ЗапрашиваемоеЗначение.Значение, ЗначениеРеквизита);
			КонецЕсли;
		КонецЕсли
	КонецЦикла;
	
КонецПроцедуры

// Получает значения по умолчанию.
// Параметры:
//		ЗаполняемыеЗначения - структура, 
//				Ключи структуры - идентификаторы запрашиваемых значений, 
//				Значения полей структуры заполняются процедурой приведены ниже.
//
//				Процедура поддерживает получение значений по умолчанию, которые 
//				зависят от других значений.
//				Например, для получения значения ДолжностьРуководителя для 
//				конкретной организации можно передать структуру с полями Организация и 
//				ДолжностьРуководителя, причем поле Организация заполнить конкретным значением.
//				В результате выполнения процедуры поле ДолжностьРуководителя
//				будет заполнено значением по умолчанию.
//
//		ЗаполненныеЗначения - (необязательный) массив, 
//				Содержит идентификаторы уже заполненных значений, 
//				Значения - уже заполненные значения.
//				На основании уже заполненных значений, могут быть 
//				заполнены, например, данные организации (НаименованиеПРФ и т.п.).
//		
//		Допустимые идентификаторы запрашиваемых значений - см. СписокДоступныхЗначенийПоУмолчанию:
//
Процедура ПолучитьЗначенияПоУмолчанию(ЗаполняемыеЗначения, ДатаЗначений = НеОпределено) Экспорт
	
	ДатаЗначений = ДатаЗаполненияЗначений(ДатаЗначений);
	
	ЗначенияЗаполняемыеПоУмолчанию = ЗначенияЗаполняемыеПоУмолчанию(ЗаполняемыеЗначения);
	   
	// Значения по умолчанию получаем в цикле для того, чтобы заполнить как 
	// "первичные", так и зависимые значения.
	// Например, на первой итерации могли получить значение для поля Организация, 
	// а на следующей итерации - значение для поля НаименованиеПФР.
	Пока Истина Цикл
		
		НеОпределеноДо = КоличествоНеОпределенныхЗначений(ЗаполняемыеЗначения);
		
		ЗаполнитьЗначенияПоУмолчанию(ЗаполняемыеЗначения, ЗначенияЗаполняемыеПоУмолчанию, ДатаЗначений);
		
		ПолучитьЕдинственныеЗначенияТипов(ЗаполняемыеЗначения);
		
		НеОпределеноПосле = КоличествоНеОпределенныхЗначений(ЗаполняемыеЗначения);
		
		Если ЗаполнениеЗначенийЗакончено(НеОпределеноДо, НеОпределеноПосле) Тогда
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ЗаполнитьЗначенияПоУмолчанию(ЗаполняемыеЗначения, ЗначенияЗаполняемыеПоУмолчанию, ДатаЗначений)
	
	ЗаполнитьЗначенияСвойств(ЗначенияЗаполняемыеПоУмолчанию, ЗаполняемыеЗначения);
	
	ЗарплатаКадрыВнутренний.ПолучитьЗначенияПоУмолчанию(ЗначенияЗаполняемыеПоУмолчанию, ДатаЗначений);
	ЗарплатаКадрыПереопределяемый.ПолучитьЗначенияПоУмолчанию(ЗначенияЗаполняемыеПоУмолчанию, ДатаЗначений);
	ЗаполнитьЗначениеОрганизацииПоУмолчанию(ЗначенияЗаполняемыеПоУмолчанию);
	
	ЗаполнитьЗначенияСвойств(ЗаполняемыеЗначения, ЗначенияЗаполняемыеПоУмолчанию);
	
КонецПроцедуры

Функция ЗначенияЗаполняемыеПоУмолчанию(ЗаполняемыеЗначения)
	
	ПоддерживаемыеИдентификаторы = ЗарплатаКадрыВнутренний.СписокДоступныхЗначенийПоУмолчанию();
	
	ЗначенияЗаполняемыеПоУмолчанию = Новый Структура;
	
	Для Каждого КлючЗначение Из ЗаполняемыеЗначения Цикл
		
		Если ПоддерживаемыеИдентификаторы.Найти(КлючЗначение.Ключ) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ЗначенияЗаполняемыеПоУмолчанию.Вставить(КлючЗначение.Ключ);
		
	КонецЦикла;
	
	Возврат ЗначенияЗаполняемыеПоУмолчанию;
	
КонецФункции

Функция ЗаполнениеЗначенийЗакончено(НеОпределеноДо, НеОпределеноПосле)
	// Ничего не заполнили или уже все заполнили.
	Возврат НеОпределеноДо = НеОпределеноПосле Или НеОпределеноПосле = 0
КонецФункции

Функция ДатаЗаполненияЗначений(ДатаЗначений)
	
	Если ДатаЗначений = НеОпределено Тогда
		ДатаЗначений = ОбщегоНазначения.ТекущаяДатаПользователя();
	КонецЕсли;

	Возврат ДатаЗначений;
	
КонецФункции

// Заполняет значение организации, если организация в коллекции запрашиваемых данных еще не заполнена.
// Значение организации получается из настроек пользователя по ключу объекта настроек "НастройкиПользователя"
// и ключу настроек "Организация". Если значения в настройках нет, заполняется первой доступной организацией.
//
Процедура ЗаполнитьЗначениеОрганизацииПоУмолчанию(ЗаполняемыеЗначения)
	
	Если ЗаполняемыеЗначения.Свойство("Организация") И НЕ ЗначениеЗаполнено(ЗаполняемыеЗначения.Организация) Тогда
		
		Организация = ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить("НастройкиПользователя", "Организация");
		Если ЗначениеЗаполнено(Организация) Тогда
			
			// Проверка доступности организации по РЛС.
			Запрос = Новый Запрос;
			Запрос.УстановитьПараметр("Организация", Организация);
			
			Запрос.Текст =
				"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
				|	Организации.Ссылка
				|ИЗ
				|	Справочник.Организации КАК Организации
				|ГДЕ
				|	Организации.Ссылка = &Организация";
				
			Выборка = Запрос.Выполнить().Выбрать();
			Если НЕ Выборка.Следующий() Тогда
				Организация = Справочники.Организации.ПустаяСсылка();
			КонецЕсли;
			
		КонецЕсли;
		
		Если ЗначениеЗаполнено(Организация) Тогда
			ЗаполняемыеЗначения.Организация = Организация;
		КонецЕсли;
		
	КонецЕсли;
	
КонецПроцедуры

// Процедура получает ссылочные значений, имеющиеся в базе в единственном экземпляре.
// Параметры:
//		ЗаполняемыеЗначения - структура, 
//				Ключи структуры - идентификаторы запрашиваемых значений, 
//				Значения полей должны быть заполнены, как минимум пустой ссылкой(для ссылочных полей).
//
// Допущения реализации:
//	1. Если в переданной структуре находятся 2 элемента одинакового типа
// 		и этот тип является типом владельца подбираемого значения, то в качестве владельца всегда будет использоваться
// 		первый заполненный элемент.
//  2. Не учитываются возможные связи параметров выбора.
//
Процедура ПолучитьЕдинственныеЗначенияТипов(ЗаполняемыеЗначения) Экспорт

	ТипыИзвестныхЗначений = Новый Соответствие;
	Для каждого ЗаполняемоеЗначение Из ЗаполняемыеЗначения Цикл
		
		ТипЗначения = ТипЗнч(ЗаполняемоеЗначение.Значение);
		Если НЕ ОбщегоНазначения.ЭтоСсылка(ТипЗначения) Тогда
			Продолжить;
		КонецЕсли; 
		
		Если ЗначениеЗаполнено(ЗаполняемоеЗначение.Значение) Тогда
			ТипыИзвестныхЗначений.Вставить(ЗаполняемоеЗначение.Значение , Метаданные.НайтиПоТипу(ТипЗначения));
		КонецЕсли; 
		
	КонецЦикла;
	
	Запрос = Новый Запрос;
	ТекстОсновногоЗапроса  = "";
	
	СтрокаЗаменыОбъединить  = "
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|";
	
	СтрокаЗаменыРазрешенные = "РАЗРЕШЕННЫЕ";
	
	НомерПараметра = 0;
	
	Для каждого ЗаполняемоеЗначение Из ЗаполняемыеЗначения Цикл
		Если ЗначениеЗаполнено(ЗаполняемоеЗначение.Значение) ИЛИ ЗаполняемоеЗначение.Значение = Неопределено Тогда
			Продолжить;	
		КонецЕсли;
		
		Тип = ТипЗнч(ЗаполняемоеЗначение.Значение);
		Если НЕ ОбщегоНазначения.ЭтоСсылка(Тип) Тогда
			Продолжить;
		КонецЕсли; 
		
		УсловиеПоВладельцу = "";
		МетаданныеТипа = Метаданные.НайтиПоТипу(Тип);
		Если ОбщегоНазначения.ЭтоСправочник(МетаданныеТипа) И МетаданныеТипа.Владельцы.Количество() > 0 Тогда
			
			Для каждого ИзвестныеЗначения Из ТипыИзвестныхЗначений Цикл
				
				Если МетаданныеТипа.Владельцы.Содержит(ИзвестныеЗначения.Значение) Тогда
					УсловиеПоВладельцу = "ГДЕ " + МетаданныеТипа.Имя + ".Владелец = &Владелец" + МетаданныеТипа.Имя;
					Запрос.УстановитьПараметр("Владелец" + МетаданныеТипа.Имя, ИзвестныеЗначения.Ключ);
					Прервать;
				КонецЕсли;
				
			КонецЦикла;
			
			Если ПустаяСтрока(УсловиеПоВладельцу) Тогда
				УсловиеПоВладельцу = "ГДЕ " + МетаданныеТипа.Имя + ".Владелец = НЕОПРЕДЕЛЕНО";;
			КонецЕсли; 
			
		КонецЕсли; 
		
		ТекстОсновногоЗапроса = СтрЗаменить(ТекстОсновногоЗапроса, "#ОБЪЕДИНИТЬ#", СтрокаЗаменыОбъединить);
		
		ТекстОсновногоЗапроса = ТекстОсновногоЗапроса + "ВЫБРАТЬ #РАЗРЕШЕННЫЕ# ПЕРВЫЕ 2 """ + ЗаполняемоеЗначение.Ключ + """ КАК Поле,
		|	" + МетаданныеТипа.Имя + ".Ссылка КАК Ссылка
		| из " + МетаданныеТипа.ПолноеИмя() + " КАК " + МетаданныеТипа.Имя + "    
		|" + УсловиеПоВладельцу + "
		|#ОБЪЕДИНИТЬ#";
		
		ТекстОсновногоЗапроса = СтрЗаменить(ТекстОсновногоЗапроса, "#РАЗРЕШЕННЫЕ#", СтрокаЗаменыРазрешенные);
		СтрокаЗаменыРазрешенные = "";
	КонецЦикла;
	
	ТекстОсновногоЗапроса = СтрЗаменить(ТекстОсновногоЗапроса, "#ОБЪЕДИНИТЬ#", "
	|ИТОГИ ПО
	| Поле");
	
	Если НЕ ПустаяСтрока(ТекстОсновногоЗапроса) Тогда
		Запрос.Текст = ТекстОсновногоЗапроса;
		Результат = Запрос.Выполнить();
		Если Не Результат.Пустой() Тогда
			Выборка = Результат.Выбрать(ОбходРезультатаЗапроса.ПоГруппировкам);
			Пока Выборка.Следующий() Цикл
				ВыборкаПоПолю = Выборка.Выбрать();
				Если ВыборкаПоПолю.Количество() = 1 Тогда
					ВыборкаПоПолю.Следующий();
					ЗаполняемыеЗначения[ВыборкаПоПолю.Поле] = ВыборкаПоПолю.Ссылка;
				КонецЕсли;
			КонецЦикла;	
		КонецЕсли;
	КонецЕсли;
КонецПроцедуры

#КонецОбласти

// Возвращает ссылку на первую из упорядоченных по алфавиту, доступную организацию.
//
// Возвращаемое значение:
//		СправочникСсылка.Организации
//
Функция ПерваяДоступнаяОрганизация() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
		|	Организации.Ссылка
		|ИЗ
		|	Справочник.Организации КАК Организации
		|
		|УПОРЯДОЧИТЬ ПО
		|	Организации.Наименование";
		
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		Организация = Выборка.Ссылка;
	Иначе
		Организация = Справочники.Организации.ПустаяСсылка();
	КонецЕсли;
	
	Возврат Организация;
			
КонецФункции

// Процедура заполняет значение реквизитов "РегистрацияВНалоговомОргане" и т.п.
// Перед записью организации для подразделений, владельцем которых она является
// или перед записью подразделения для подчиненных элементов.
//
//	Параметры:
//		ИсточникДанных - источник данных для записи реквизитов.
//			Объект, содержащий свойства.
//				Ссылка (СправочникСсылка.Организации или СправочникСсылка.ПодразделенияОрганизаций).
//				Наименование
//				РегистрацияВНалоговомОргане
//				РайонныйКоэффициент.
//				РайонныйКоэффициентРФ - не обязательно.
//				СоответствуетСудамЗарегистрированнымВРоссийскомМеждународномРеестреСудов - не обязательно.
//
Процедура УстановитьРеквизитыВПодчиненныхПодразделениях(ИсточникДанных) Экспорт
	
	ВыполняетсяЗаписьОрганизации = (ТипЗнч(ИсточникДанных.Ссылка) = Тип("СправочникСсылка.Организации"));
	
	Если Не ВыполняетсяЗаписьОрганизации И ИсточникДанных.ДополнительныеСвойства.ОбособленноеПодразделение = ИсточникДанных.ОбособленноеПодразделение
		И Не ИсточникДанных.ОбособленноеПодразделение Тогда
		// Не обновляем подчиненные структурные единицы, т.к. ничего не изменилось.
		ПодчиненныеСтруктурныеЕдиницы = Новый Структура("ГоловнаяСтруктурнаяЕдиница, ПодчиненныеСтруктурныеЕдиницы", Неопределено, Новый Массив);
	Иначе
		ПодчиненныеСтруктурныеЕдиницы = Справочники.ПодразделенияОрганизаций.ПодчиненныеСтруктурныеЕдиницы(ИсточникДанных.Ссылка);
		Если Не ВыполняетсяЗаписьОрганизации
			И ИсточникДанных.ДополнительныеСвойства.ОбособленноеПодразделение <> ИсточникДанных.ОбособленноеПодразделение
			И Не ИсточникДанных.ОбособленноеПодразделение Тогда
			ПодчиненныеСтруктурныеЕдиницы.ПодчиненныеСтруктурныеЕдиницы.Добавить(ИсточникДанных.Ссылка);
		КонецЕсли;
		РегистрыСведений.ТерриториальныеУсловияПФР.ОбновитьПодчиненныеСтруктурныеЕдиницы(ПодчиненныеСтруктурныеЕдиницы);
		РегистрыСведений.ИсторияРегистрацийВНалоговомОргане.ОбновитьПодчиненныеСтруктурныеЕдиницы(ПодчиненныеСтруктурныеЕдиницы);
	КонецЕсли;
	
	Запрос = Новый Запрос;
	
	Запрос.УстановитьПараметр("ПодчиненныеСтруктурныеЕдиницы", ПодчиненныеСтруктурныеЕдиницы.ПодчиненныеСтруктурныеЕдиницы);
	
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ПодразделенияОрганизаций.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник.ПодразделенияОрганизаций КАК ПодразделенияОрганизаций
	|ГДЕ
	|	(&УсловияПроверкиНеобходимостиОбновления)
	|	И ПодразделенияОрганизаций.Ссылка В(&ПодчиненныеСтруктурныеЕдиницы)
	|	И &ПодчиненВладельцу";
	
	Если ВыполняетсяЗаписьОрганизации Тогда
		УсловиеЗапроса = "ПодразделенияОрганизаций.Владелец = &Владелец";
	Иначе
		УсловиеЗапроса = "ПодразделенияОрганизаций.Родитель В ИЕРАРХИИ (&Владелец)";
	КонецЕсли;
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&ПодчиненВладельцу", УсловиеЗапроса);
	
	// Условия проверки необходимости обновления.
	УсловияПроверкиНеобходимостиОбновления = "";
	УсловияЗапроса = УсловияЗапросаПроверкиНеобходимостиЗаполненияПодчиненныхПодразделений(Запрос, ИсточникДанных);
	Для каждого УсловиеЗапроса Из УсловияЗапроса Цикл
		УсловияПроверкиНеобходимостиОбновления = ?(ПустаяСтрока(УсловияПроверкиНеобходимостиОбновления), "", УсловияПроверкиНеобходимостиОбновления + Символы.ПС + "ИЛИ ")
			+ УсловиеЗапроса;
	КонецЦикла;
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "&УсловияПроверкиНеобходимостиОбновления", УсловияПроверкиНеобходимостиОбновления);
	
	Запрос.УстановитьПараметр("Владелец", ИсточникДанных.Ссылка);
	
	Результат = Запрос.Выполнить();
	ВыборкаПодразделений = Результат.Выбрать();
	
	Пока ВыборкаПодразделений.Следующий() Цикл
		ПодразделениеОбъект = ВыборкаПодразделений.Ссылка.ПолучитьОбъект();
		Попытка
			ПодразделениеОбъект.Заблокировать();
		Исключение
			ТекстИсключенияЗаписи = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не удалось изменить подчиненное подразделение %1 при записи %2.
			|Возможно, подразделение редактируется другим пользователем'"),
			ПодразделениеОбъект.Наименование, ИсточникДанных.Наименование);
			ВызватьИсключение ТекстИсключенияЗаписи;
		КонецПопытки;
		
		ЗаполнитьПодчиненноеПодразделение(ПодразделениеОбъект, ИсточникДанных);
		
		ПодразделениеОбъект.ДополнительныеСвойства.Вставить("ОбработкаЗаписиРодителя", Истина);
		ПодразделениеОбъект.ОбменДанными.Загрузка = Истина;
		ПодразделениеОбъект.Записать();
	КонецЦикла;
	
КонецПроцедуры

// Выполняет формирование таблицы с набором значений доступа объекта (документа), 
// содержащего ссылки на организацию и сотрудника (сотрудников).
// Вызывается из процедуры ЗаполнитьНаборыЗначенийДоступа, реализованной в модуле таких 
// документов, доступ к которым выполняется через наборы значений доступа.
// Параметры:
//		Объект
//		Таблица - переданная таблица значений.
//		ПутьОрганизация - строка с именем реквизита, содержащего организацию.
//		ПутьФизическоеЛицо - строка с именем реквизита, содержащего физическое лицо.
//			Может быть идентификатором реквизита объекта (например, "ФизическоеЛицо") или
//			путем к реквизиту табличной части в 
//			формате <ИмяТабличнойЧасти>.<ИмяРеквизита> 
//			(например, "ФизическиеЛица.ФизическоеЛицо")
//
Процедура ЗаполнитьНаборыПоОрганизацииИФизическимЛицам(Объект, Таблица, ПутьОрганизация, ПутьФизическоеЛицо, НомерНабора = 0) Экспорт
	
	// Логика ограничения:
	// объект доступен, если доступна организация и все физические лица
	
	СтрокаТаб = Таблица.Добавить();
	СтрокаТаб.ЗначениеДоступа = Объект[ПутьОрганизация];
	СтрокаТаб.НомерНабора = НомерНабора;
	
	СтрокиПутиФизическогоЛица = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПутьФизическоеЛицо, ".");
	Если СтрокиПутиФизическогоЛица.Количество() = 1 Тогда
		СтрокаТаб = Таблица.Добавить();
		СтрокаТаб.ЗначениеДоступа = Объект[ПутьФизическоеЛицо];
		СтрокаТаб.НомерНабора = НомерНабора;
		
	Иначе
		Для Каждого СтрокаТаблицы Из Объект[СтрокиПутиФизическогоЛица[0]] Цикл
			СтрокаТаб = Таблица.Добавить();
			СтрокаТаб.ЗначениеДоступа = СтрокаТаблицы[СтрокиПутиФизическогоЛица[1]];
			СтрокаТаб.НомерНабора = НомерНабора;
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Функция определяет является ли организация юридическим лицом 
// "по правилам" регламентированной отчетности.
// 
Функция ЭтоЮридическоеЛицо(Организация) Экспорт
	Возврат ЗарплатаКадрыПовтИсп.ЭтоЮридическоеЛицо(Организация);
КонецФункции

// Помещает в переданный массив имена реквизитов формы.
// Параметры:
//		Форма
//		МассивИменРеквизитовФормы
//      ПутьКДанным
//
Процедура ЗаполнитьМассивИменРеквизитовФормы(Форма, МассивИменРеквизитовФормы,  ПутьКДанным = "") Экспорт
	
	Если ЗначениеЗаполнено(ПутьКДанным) Тогда
		МассивРеквизитовФормы = Форма.ПолучитьРеквизиты(ПутьКДанным);
	Иначе
		МассивРеквизитовФормы = Форма.ПолучитьРеквизиты();
	КонецЕсли;
	
	Для Каждого Реквизит Из МассивРеквизитовФормы Цикл
		МассивИменРеквизитовФормы.Добавить(?(ЗначениеЗаполнено(ПутьКДанным), ПутьКДанным + ".", "") + Реквизит.Имя);	
	КонецЦикла;
	
КонецПроцедуры

// Изменяет реквизиты формы
// Параметры:
// 		Форма, 
//		ДобавляемыеРеквизиты - массив добавляемых реквизитов.
//		СуществующиеРеквизиты - массив текущих реквизитов формы. Можно получить при помощи
//		                        ЗарплатаКадры.ЗаполнитьМассивИменРеквизитовФормы.
//		УдаляемыеРеквизиты - не обязательный. Массив удаляемых реквизитов.
//
// Выполняет "замену" существующих реквизитов формы новыми одноименными реквизитами. Используется при дополнении форм
// реквизитами.
// Позволяет генерировать реквизиты формы не анализируя создавались ли в ней уже те или иные реквизиты.
Процедура ИзменитьРеквизитыФормы(Форма, ДобавляемыеРеквизиты, СуществующиеРеквизиты, УдаляемыеРеквизиты = Неопределено) Экспорт
	
	Если УдаляемыеРеквизиты = Неопределено Тогда 
		УдаляемыеРеквизиты = Новый Массив;
	КонецЕсли;
	
	Для Каждого Реквизит Из ДобавляемыеРеквизиты Цикл
		Если СуществующиеРеквизиты.Найти(?(ЗначениеЗаполнено(Реквизит.Путь), Реквизит.Путь + ".", "") + Реквизит.Имя) <> Неопределено 
			И УдаляемыеРеквизиты.Найти(?(ЗначениеЗаполнено(Реквизит.Путь), Реквизит.Путь + ".", "") + Реквизит.Имя) = Неопределено Тогда
			УдаляемыеРеквизиты.Добавить(?(ЗначениеЗаполнено(Реквизит.Путь), Реквизит.Путь + ".", "") + Реквизит.Имя);
		КонецЕсли;					
	КонецЦикла;		
	
	Форма.ИзменитьРеквизиты(ДобавляемыеРеквизиты, УдаляемыеРеквизиты);
	
КонецПроцедуры

// Удаляет все элементы, подчиненные группе элементов формы.
Процедура УдалитьПодчиненныеЭлементыГруппы(Форма, ГруппаФормы) Экспорт 
	
	ЭлементыДляУдаления = Новый Массив;
	Для Каждого Элемент Из ГруппаФормы.ПодчиненныеЭлементы Цикл
		ЭлементыДляУдаления.Добавить(Элемент);
	КонецЦикла;
	
	Для Каждого Элемент Из ЭлементыДляУдаления Цикл
		Форма.Элементы.Удалить(Элемент);
	КонецЦикла;
	
КонецПроцедуры

// Предназначена для использования в ОбщегоНазначенияПереопределяемый.ЗаполнитьТаблицуПереименованияОбъектовМетаданных.
//
// Заполняет переименования тех объектов метаданных, которые невозможно
// автоматически найти по типу, но ссылки на которые требуется сохранять
// в базе данных (например: подсистемы, роли).
//
// Подробнее: см. ОбщегоНазначения.ДобавитьПереименование().
//
Процедура ЗаполнитьТаблицуПереименованияОбъектовМетаданных(Итог) Экспорт
	
	ЗарплатаКадрыВнутренний.ЗаполнитьТаблицуПереименованияОбъектовМетаданных(Итог);
	
КонецПроцедуры

// Возвращает ссылку на валюту в которой происходит расчет заработной платы (рубль РФ).
// Номинирование тарифов, надбавок, выплата зарплаты допускается в любой валюте, 
// но расчеты выполняются в валюте учета зарплаты.
Функция ВалютаУчетаЗаработнойПлаты() Экспорт
	
	Возврат ЗарплатаКадрыПовтИсп.ВалютаУчетаЗаработнойПлаты();
	
КонецФункции

// Возвращает соответствие Физлицо - ФИО на дату
// относящихся к персональным.
//
// Параметры:
//		ДатаАктуальности - дата, на которую определяется ФИО:
//		МассивФизЛиц - массив ссылок типа СправочникСсылка.ФизическиеЛица.
//
// Возвращаемое значение:
//		соответствие	
//			ключ - СправочникСсылка.ФизическиеЛица
//			значение - строка ФИО
//
//
Функция СоответствиеФИОФизЛицСсылкам(ДатаАктуальности, МассивФизЛиц) Экспорт 
	
	МассивНеобходимыхПолей = Новый Массив;
	МассивНеобходимыхПолей.Добавить("Фамилия");
	МассивНеобходимыхПолей.Добавить("Имя");
	МассивНеобходимыхПолей.Добавить("Отчество");
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	КадровыйУчет.СоздатьНаДатуВТКадровыеДанныеФизическихЛиц(Запрос.МенеджерВременныхТаблиц, Истина, МассивФизЛиц, МассивНеобходимыхПолей, ДатаАктуальности);
	
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	КадровыеДанныеФизЛиц.ФизическоеЛицо,
	|	КадровыеДанныеФизЛиц.Фамилия,
	|	КадровыеДанныеФизЛиц.Имя,
	|	КадровыеДанныеФизЛиц.Отчество
	|ИЗ
	|	ВТКадровыеДанныеФизическихЛиц КАК КадровыеДанныеФизЛиц";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	СоответствиеФИОФизЛицСсылкам = Новый Соответствие;
	
	Пока Выборка.Следующий() Цикл
		ФИО = Новый Структура("Фамилия, Имя, Отчество");
		ЗаполнитьЗначенияСвойств(ФИО, Выборка);
		СоответствиеФИОФизЛицСсылкам.Вставить(Выборка.ФизическоеЛицо, ФИО);		
	КонецЦикла;	
	
	Возврат СоответствиеФИОФизЛицСсылкам;
	
КонецФункции	

// Преобразовывает переданные массивы сотрудников и физических лиц в строку 
// вида <Фамилия И.О., Фамилия И.О...>.
// Используется для заполнения краткого состава документов.
//
// Параметры:
//	- Сотрудники - массив элементов типа СправочникСсылка.Сотрудники,
//	- ДатаАктуальности - дата для получения фамилии, имени и отчества.
//	- Физлица - необязательный, массив элементов типа СправочникСсылка.ФизическиеЛица.
//	- ФизлицаСотрудников - соответствие Сотрудник - Физическое лицо.
//
Функция КраткийСоставСотрудников(Сотрудники, ДатаАктуальности, Физлица = Неопределено, ФизлицаСотрудников = Неопределено) Экспорт
	
	Если ФизлицаСотрудников = Неопределено Тогда
		ФизлицаСотрудников = ОбщегоНазначения.ЗначениеРеквизитаОбъектов(Сотрудники, "ФизическоеЛицо");
	КонецЕсли;
	
	// Первые N человек и M символов.
	МаксимальноеКоличествоФизическихЛиц = 10;
	МаксимальнаяДлинаСтроки = 100;

	Счетчик = 0;
	ПервыеФизлица = Новый Массив;
	УникальныеФизлица = Новый Соответствие;
	Для Каждого Сотрудник Из Сотрудники Цикл
		Если Счетчик = МаксимальноеКоличествоФизическихЛиц Тогда
			Прервать;
		КонецЕсли;
		Физлицо = ФизлицаСотрудников[Сотрудник];
		Если Не ЗначениеЗаполнено(Физлицо) 
			Или УникальныеФизлица[Физлицо] <> Неопределено Тогда
			Продолжить;	
		КонецЕсли;
		ПервыеФизлица.Добавить(Физлицо);
		УникальныеФизлица.Вставить(Физлицо, Истина);
		Счетчик = Счетчик + 1;
	КонецЦикла;
	
	// Если физлиц сотрудников не достаточно, 
	// добавляем данные табличных частей, где непосредственно Физические лица.
	Если Счетчик < МаксимальноеКоличествоФизическихЛиц И Физлица <> Неопределено Тогда
		Для Каждого Физлицо Из Физлица Цикл
			Если Счетчик = МаксимальноеКоличествоФизическихЛиц Тогда
				Прервать;
			КонецЕсли;
			Если Не ЗначениеЗаполнено(Физлицо) 
				Или УникальныеФизлица[Физлицо] <> Неопределено Тогда
				Продолжить;	
			КонецЕсли;
			ПервыеФизлица.Добавить(Физлицо);
			УникальныеФизлица.Вставить(Физлицо, Истина);
			Счетчик = Счетчик + 1;
		КонецЦикла;
	КонецЕсли;
	
	ИменаФизлиц = ЗарплатаКадры.СоответствиеФИОФизЛицСсылкам(ДатаАктуальности, ПервыеФизлица);
	
	КраткийСостав = "";
	Для Каждого Физлицо Из ПервыеФизлица Цикл
		Если Не ПустаяСтрока(КраткийСостав) Тогда
			КраткийСостав = КраткийСостав + ", ";
		КонецЕсли;
		ФИО = ИменаФизлиц[Физлицо];
		КраткийСостав = КраткийСостав + ФизическиеЛицаКлиентСервер.ФамилияИнициалыФизЛица(Неопределено, ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);
	КонецЦикла;
	Если СтрДлина(КраткийСостав) > МаксимальнаяДлинаСтроки Тогда
		КраткийСостав = Лев(КраткийСостав, МаксимальнаяДлинаСтроки - 3) + "...";
	КонецЕсли;
	
	Возврат КраткийСостав;

КонецФункции

// Преобразовывает переданный массив физических лиц в строку 
// вида <Фамилия И.О., Фамилия И.О...>.
// Используется для представления краткого состава документов.
//
// Параметры:
//	- Физлица - массив элементов типа СправочникСсылка.ФизическиеЛица,
//	- ДатаАктуальности - дата для получения фамилии, имени и отчества.
//	- МаксимальнаяДлинаСтроки - необязательный, максимальная длина результирующей строки.
//
Функция КраткийСоставФизЛиц(ФизЛица, ДатаАктуальности, МаксимальнаяДлинаСтроки = 100) Экспорт
	
	ФИОФизЛиц = ЗарплатаКадры.СоответствиеФИОФизЛицСсылкам(ДатаАктуальности, ФизЛица);
	
	КраткийСостав = "";
	Для Каждого ФизЛицо Из ФизЛица Цикл
		Если Не ПустаяСтрока(КраткийСостав) Тогда
			КраткийСостав = КраткийСостав + ", ";
		КонецЕсли;
		ФИО = ФИОФизЛиц[ФизЛицо];
		КраткийСостав = КраткийСостав + ФизическиеЛицаКлиентСервер.ФамилияИнициалыФизЛица(Неопределено, ФИО.Фамилия, ФИО.Имя, ФИО.Отчество);
	КонецЦикла;
	Если СтрДлина(КраткийСостав) > МаксимальнаяДлинаСтроки Тогда
		КраткийСостав = Лев(КраткийСостав, МаксимальнаяДлинаСтроки - 3) + "...";
	КонецЕсли;
	
	Возврат КраткийСостав;

КонецФункции

// Возвращает Истина, если объект метаданных входит в состав подсистем зарплатно кадровой библиотеки.
//
// Параметры:
//		ПолноеИмяОбъектаМетаданных
//
// Возвращаемое значение:
//		Булево
//
Функция ЭтоОбъектЗарплатноКадровойБиблиотеки(ПолноеИмяОбъектаМетаданных) Экспорт
	
	Возврат ЗарплатаКадрыВнутренний.ЭтоОбъектЗарплатноКадровойБиблиотеки(ПолноеИмяОбъектаМетаданных);;
	
КонецФункции

Функция ЭтоБазоваяВерсияКонфигурации() Экспорт
	Возврат ЗарплатаКадрыВнутренний.ЭтоБазоваяВерсияКонфигурации();
КонецФункции

// Сохраняет в настройках значения ответственных работников организации.
//
// Параметры:
//		Организация			- СправочникСсылка.Организации
//		СохраняемыеЗначения - Структура, ключи идентификаторы данных (см. функцию СписокДоступныхЗначенийПоУмолчанию).
//
Процедура СохранитьЗначенияЗаполненияОтветственныхРаботников(Организация, СохраняемыеЗначения) Экспорт
	
	Если ЗначениеЗаполнено(Организация) И СохраняемыеЗначения.Количество() > 0 Тогда
		
		СведенияОбОтветственныхРаботниках = ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить("НастройкиПользователя", "СведенияОбОтветственныхРаботниках");
		Если СведенияОбОтветственныхРаботниках = Неопределено Тогда
			СведенияОбОтветственныхРаботниках = Новый Соответствие;
		КонецЕсли;
		
		СведенияПоОрганизации = СведенияОбОтветственныхРаботниках.Получить(Организация);
		Если СведенияПоОрганизации = Неопределено Тогда
			СведенияПоОрганизации = Новый Структура;
		КонецЕсли;
		
		Для каждого ОписаниеЗначения Из СохраняемыеЗначения Цикл
			СведенияПоОрганизации.Вставить(ОписаниеЗначения.Ключ, ОписаниеЗначения.Значение);
		КонецЦикла;
		
		СведенияОбОтветственныхРаботниках.Вставить(Организация, СведенияПоОрганизации);
		
		ОбщегоНазначения.ХранилищеОбщихНастроекСохранить("НастройкиПользователя", "СведенияОбОтветственныхРаботниках", СведенияОбОтветственныхРаботниках);
		
	КонецЕсли; 
	
КонецПроцедуры

// Заполняет свойства об ответственных работниках организаций. Организация передается в
// параметре ЗаполняемыеЗначения в свойстве структуры "Организация".
//
// Параметры:
//		ЗаполняемыеЗначения		- Структура
//
Процедура ЗаполнитьСведенияОбОтветственныхРаботникахОрганизаций(ЗаполняемыеЗначения) Экспорт
	
	ОрганизацияСсылка = НеОпределено;
	Если ЗаполняемыеЗначения.Свойство("Организация", ОрганизацияСсылка) И ЗначениеЗаполнено(ОрганизацияСсылка) Тогда
			
		НеобходимоЗаполнение = Ложь;
		ПоддерживаемыеИдентификаторы = ПоддерживаемыеИдентификаторыОтветственныхРаботниковОрганизаций();
		Для ИндексИдентификатора = 0 По ПоддерживаемыеИдентификаторы.Количество() - 1 Цикл
			
			ПоддерживаемыйИдентификатор = ПоддерживаемыеИдентификаторы[ИндексИдентификатора];
			
			ЗаполняемоеЗначение = Неопределено;
			Если ЗаполняемыеЗначения.Свойство(ПоддерживаемыйИдентификатор, ЗаполняемоеЗначение) И НЕ ЗначениеЗаполнено(ЗаполняемоеЗначение) Тогда
				НеобходимоЗаполнение = Истина;
				Прервать;
			КонецЕсли;
			
		КонецЦикла;
		
		Если НеобходимоЗаполнение Тогда
			
			СведенияОбОтветственныхРаботниках = ОбщегоНазначения.ХранилищеОбщихНастроекЗагрузить("НастройкиПользователя", "СведенияОбОтветственныхРаботниках");
			Если СведенияОбОтветственныхРаботниках <> Неопределено Тогда
				
				СведенияПоОрганизации = СведенияОбОтветственныхРаботниках.Получить(ОрганизацияСсылка);
				Если СведенияПоОрганизации <> Неопределено Тогда
						
					ДлинаМодификатораСтрокой = СтрДлина("Строкой");
					Для ИндексОбрабатываемогоИдентификатора = ИндексИдентификатора По ПоддерживаемыеИдентификаторы.Количество() - 1 Цикл
						
						ПоддерживаемыйИдентификатор = ПоддерживаемыеИдентификаторы[ИндексОбрабатываемогоИдентификатора];
				
						ЗаполняемоеЗначение = Неопределено;
						Если ЗаполняемыеЗначения.Свойство(ПоддерживаемыйИдентификатор, ЗаполняемоеЗначение) И НЕ ЗначениеЗаполнено(ЗаполняемоеЗначение) Тогда
							
							ИдентификаторДляПолученияПредставления = "";
							Если ВРег(Прав(ПоддерживаемыйИдентификатор, ДлинаМодификатораСтрокой)) = ВРег("Строкой") Тогда
								ИдентификаторДляПолученияПредставления = Лев(ПоддерживаемыйИдентификатор, СтрДлина(ПоддерживаемыйИдентификатор) - ДлинаМодификатораСтрокой);
							КонецЕсли; 
						
							Если ПустаяСтрока(ИдентификаторДляПолученияПредставления) Тогда
								СведенияПоОрганизации.Свойство(ПоддерживаемыйИдентификатор, ЗаполняемоеЗначение);
							Иначе
								
								ЗначениеДляПредставления = Неопределено;
								СведенияПоОрганизации.Свойство(ИдентификаторДляПолученияПредставления, ЗначениеДляПредставления);
								
								Если ЗначениеЗаполнено(ЗначениеДляПредставления) Тогда
									ЗаполняемоеЗначение = Строка(ЗначениеДляПредставления);
								КонецЕсли; 
								
							КонецЕсли;
							
							Если ЗначениеЗаполнено(ЗаполняемоеЗначение) Тогда
								ЗаполняемыеЗначения.Вставить(ПоддерживаемыйИдентификатор, ЗаполняемоеЗначение);
							КонецЕсли; 
							
						КонецЕсли; 
			
					КонецЦикла;
				
				КонецЕсли;
				
			КонецЕсли;
			
		КонецЕсли; 
			
	КонецЕсли; 
	
КонецПроцедуры

#Область ЗащитаПерсональныхДанных

// Процедура обеспечивает сбор сведений о хранении данных, 
// относящихся к персональным
//
// Параметры:
//		ТаблицаСведений - таблица значений с полями:
//			Объект 			- строка, содержащая полное имя объекта метаданных,
//			ПоляРегистрации - строка, в которой перечислены имена полей регистрации, 
//								отдельные поля регистрации отделяются запятой,
//								альтернативные - символом "|",
//			ПоляДоступа		- строка, в которой перечислены через запятую имена полей доступа.
//			ОбластьДанных	- строка с идентификатором области данных, необязательно для заполнения.
//
Процедура ЗаполнитьСведенияОПерсональныхДанных(ТаблицаСведений) Экспорт
	
	ЗарплатаКадрыВнутренний.ЗаполнитьСведенияОПерсональныхДанных(ТаблицаСведений);
	
КонецПроцедуры

// Процедура обеспечивает составление коллекции областей персональных данных.
//
// Параметры:
//		ОбластиПерсональныхДанных - таблица значений с полями:
//			Имя - идентификатор области данных.
//			Представление - пользовательское представление области данных.
//			Родитель - идентификатор родительской области данных.
//
Процедура ЗаполнитьОбластиПерсональныхДанных(ОбластиПерсональныхДанных) Экспорт
	
	ЗарплатаКадрыВнутренний.ЗаполнитьОбластиПерсональныхДанных(ОбластиПерсональныхДанных);
	
КонецПроцедуры

#КонецОбласти

#Область РегламентированнаяОтчетность

// Функция возвращает сведения об организации.
//
// Параметры:
//  Организация			- ссылка на элемент справочника "Организации";
//  ДатаЗначения		- дата, на которую нужно получить сведения;
//  СписокПоказателей	- список показателей, значения которых нужно вернуть.
//  
// Возвращаемое значение:
//  Структура с ключами из списка показателей и возвращаемыми значениями.
//
Функция ПолучитьСведенияОбОрганизации(Знач Организация, Знач ДатаЗначения = Неопределено, Знач СписокПоказателей = Неопределено) Экспорт
	Возврат ЗарплатаКадрыВнутренний.ПолучитьСведенияОбОрганизации(Организация, ДатаЗначения, СписокПоказателей);
КонецФункции

// Процедура заполняет список используемых регламентированных отчетов.
//
Процедура ЗаполнитьСписокРегламентированныхОтчетов(СписокРегламентированныхОтчетов) Экспорт
	ЗарплатаКадрыВнутренний.ЗаполнитьСписокРегламентированныхОтчетов(СписокРегламентированныхОтчетов);
КонецПроцедуры

// Процедура заполняет структуру показателей.
// Ключ структуры - идентификатор показателя.
// Значение структуры - массив из двух элементов:
// 	- признак автозаполнения показателя,
//	- признак расшифровки показателя.
//
// Параметры:
// 	ПоказателиОтчета - структура показателей отчета,
// 	ИДОтчета         - идентификатор отчета,
//	ИДРедакцииОтчета - идентификатор редакции формы отчета.
//
Процедура ЗаполнитьПоказателиРегламентированногоОтчета(ПоказателиОтчета, ИДОтчета, ИДРедакцииОтчета) Экспорт
	ЗарплатаКадрыВнутренний.ЗаполнитьПоказателиРегламентированногоОтчета(ПоказателиОтчета, ИДОтчета, ИДРедакцииОтчета);
КонецПроцедуры

// Процедура заполняет переданную в виде контейнера структуру данных отчета.
//
Процедура ЗаполнитьРегламентированныйОтчет(ИДОтчета, ИДРедакцииОтчета, ПараметрыОтчета, Контейнер) Экспорт
	ЗарплатаКадрыВнутренний.ЗаполнитьРегламентированныйОтчет(ИДОтчета, ИДРедакцииОтчета, ПараметрыОтчета, Контейнер);
КонецПроцедуры

// Процедура добавляет описание показателя регламентированной отчетности.
//
Процедура ДобавитьПоказательРегламентированнойОтчетности(СтруктураПоказателей, ИмяПоказателя, ПризнакАвтозаполнения, ПризнакРасшифровки) Экспорт
	РегламентированнаяОтчетность.ВставитьПоказательВСтруктуру(СтруктураПоказателей, ИмяПоказателя, ПризнакАвтозаполнения, ПризнакРасшифровки);
КонецПроцедуры

// Процедура выводит в отчет-расшифровку сообщение о расхождении значения показателя в рег.отчете с расшифровкой по
// данным учета.
//
Процедура ВывестиПредупреждениеОРасхожденииПоказателяСРасшифровкой(ТекстТекущегоПоказателя, ИтогРасшифровки, ДокументРезультат) Экспорт

	Попытка
		ЗначениеТекущегоПоказателя = Число(ТекстТекущегоПоказателя);
	Исключение                             
	    ЗначениеТекущегоПоказателя = Неопределено
	КонецПопытки;
	Если ЗначениеТекущегоПоказателя <> Неопределено И ЗначениеТекущегоПоказателя <> ИтогРасшифровки Тогда
		Макет = ПолучитьОбщийМакет("ЗаголовокРасшифровкиРегламентированногоОтчетаЗарплата");
		Макет.Параметры.ЗначениеТекущегоПоказателя = Формат(ЗначениеТекущегоПоказателя, "ЧДЦ=2; ЧГ=0");
		Макет.Параметры.ИтогРасшифровки = Формат(ИтогРасшифровки, "ЧДЦ=2; ЧГ=0");
		ДокументРезультат.Вывести(Макет);
	КонецЕсли;

КонецПроцедуры

// Функция возвращает имя справочника обособленных подразделений,
// используемого для автоматического заполнения статистической отчетности.
//
// Пример:
//  Возврат "ПодразделенияОрганизаций";
//
Функция ИмяСправочникаОбособленныхПодразделений() Экспорт
	Возврат ЗарплатаКадрыВнутренний.ИмяСправочникаОбособленныхПодразделений();	
КонецФункции

// Функция возвращает имя реквизита справочника подразделений, который
// определяет, является ли подразделение обособленным (в трактовке Росстата).
// Используется для автоматического заполнения статистической отчетности.
//
// Тип реквизита - Булево.
// Если значение реквизита равно Истина - подразделение является обособленным.
// Если значение реквизита равно Ложь - подразделение не является обособленным.
//
// Пример:
//  Возврат "ИмеетНомерТерриториальногоОрганаРосстата";
//
Функция ИмяРеквизитаПризнакаОбособленногоПодразделения() Экспорт
	Возврат ЗарплатаКадрыВнутренний.ИмяРеквизитаПризнакаОбособленногоПодразделения();
КонецФункции

#КонецОбласти

#Область УправлениеДоступом

// Обслуживание подсистемы УправлениеДоступом
// см. УправлениеДоступомПереопределяемый.ПриЗаполненииВидовДоступа.
//
Процедура УправлениеДоступомЗаполнитьСвойстваВидаДоступа(ВидыДоступа) Экспорт
	
	// Физические лица
	ВидДоступа = ВидыДоступа.Добавить();
	ВидДоступа.Имя = "ГруппыФизическихЛиц";
	ВидДоступа.Представление = НСтр("ru = 'Группы физических лиц'");
	ВидДоступа.ТипЗначений = Тип("СправочникСсылка.ФизическиеЛица");
	ВидДоступа.ТипГруппЗначений = Тип("СправочникСсылка.ГруппыДоступаФизическихЛиц");
	
	// Подразделения организаций
	ВидДоступа = ВидыДоступа.Добавить();
	ВидДоступа.Имя = "ПодразделенияОрганизаций";
	ВидДоступа.Представление = НСтр("ru = 'Подразделения организаций'");
	ВидДоступа.ТипЗначений = Тип("СправочникСсылка.ПодразделенияОрганизаций");
	
КонецПроцедуры

// Обслуживание подсистемы УправлениеДоступом
// см. УправлениеДоступом.ПриЗаполненииИспользованияВидаДоступа.
//
Процедура УправлениеДоступомЗаполнитьИспользованиеВидаДоступа(ИмяВидаДоступа, Использование) Экспорт
	
	Если ИмяВидаДоступа = "ГруппыФизическихЛиц" Тогда
		Использование = Константы.ОграничиватьДоступНаУровнеЗаписейФизическиеЛица.Получить();
	ИначеЕсли ИмяВидаДоступа = "ПодразделенияОрганизаций" Тогда
		Использование = Константы.ОграничиватьДоступНаУровнеЗаписейПодразделенияОрганизаций.Получить();
	КонецЕсли;
	
КонецПроцедуры

#КонецОбласти

#Область ЗаголовкиСвертываемыхГрупп

// Устанавливает текст заголовка, отображаемого, когда группа свернута.
// Параметры:
//		Группа - группа формы, заголовок свернутого отображения которой необходимо заполнить.
//		ОтображаемыеРеквизиты - массив путей к реквизитам формы, 
//				значения которых необходимо вывести в заголовке.
//		Заголовок - строка заголовка, если не указана, используется заголовок группы.
//		ПредставлениеНезаполненного - строка - текст, выводимый после заголовка, 
//			если ни один из отображаемых реквизитов не заполнен.
//			Значение по умолчанию: <не указано>.
//		ПредставлениеЧастичноЗаполненного - строка - текст, выводимый в конце, 
//			если хотя бы один из отображаемых реквизитов не заполнен.
//			Значение по умолчанию: (не все поля заполнены).
//
// Пример использования:
// 	ОтображаемыеРеквизиты = Новый Массив;
// 	ОтображаемыеРеквизиты.Добавить("Объект.Кассир");
// 	ОтображаемыеРеквизиты.Добавить("Объект.ГлавныйБухгалтер");
// 	ОтображаемыеРеквизиты.Добавить("Объект.Бухгалтер");
//	ЗарплатаКадры.УстановитьЗаголовокСвернутогоОтображенияГруппы(Элементы.ПодписиГруппа, ОтображаемыеРеквизиты);
//
Процедура УстановитьЗаголовокСвернутогоОтображенияГруппы(Группа, ОтображаемыеРеквизиты, Знач ЗаголовокГруппы = Неопределено, Знач ПредставлениеНезаполненного = Неопределено, Знач ПредставлениеЧастичноЗаполненного = Неопределено) Экспорт
	
	Форма = ФормаЭлемента(Группа);

	ОтображаемыеЗначения = Новый Массив;
	Для Каждого ОтображаемыйРеквизит Из ОтображаемыеРеквизиты Цикл
		ОтображаемыеЗначения.Добавить(ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, ОтображаемыйРеквизит));
	КонецЦикла;
	
	Если ЗаголовокГруппы = Неопределено Тогда
		ЗаголовокГруппы = Группа.Заголовок
	КонецЕсли;
	
	Группа.ЗаголовокСвернутогоОтображения = ЗаголовокСвернутогоОтображенияГруппы(ЗаголовокГруппы, ОтображаемыеЗначения, ПредставлениеНезаполненного, ПредставлениеЧастичноЗаполненного);
	
КонецПроцедуры

// Настраивает отображение группы с подписями ответственных лиц документа.
// Параметры:
//		Группа - группа формы с ответственными лицами.
//		Физлицо1...Физлицо9 - путь к реквизиту формы с ответственным лицом.
//
// Пример использования:
//	ЗарплатаКадры.НастроитьОтображениеГруппыПодписей(Элементы.ПодписиГруппа, "Объект.Кассир", "Объект.ГлавныйБухгалтер", "Объект.Бухгалтер");
//
Процедура НастроитьОтображениеГруппыПодписей(Группа, 
		Знач Физлицо1 = Неопределено, Знач Физлицо2 = Неопределено, Знач Физлицо3 = Неопределено,
		Знач Физлицо4 = Неопределено, Знач Физлицо5 = Неопределено, Знач Физлицо6 = Неопределено,
		Знач Физлицо7 = Неопределено, Знач Физлицо8 = Неопределено, Знач Физлицо9 = Неопределено) Экспорт
	
	Форма = ФормаЭлемента(Группа);

	СписокФизлиц = Новый Массив;
	Если ЗначениеЗаполнено(Физлицо1) Тогда 
		СписокФизлиц.Добавить(ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, Физлицо1));
	КонецЕсли;
	Если ЗначениеЗаполнено(Физлицо2) Тогда 
		СписокФизлиц.Добавить(ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, Физлицо2));
	КонецЕсли;
	Если ЗначениеЗаполнено(Физлицо3) Тогда 
		СписокФизлиц.Добавить(ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, Физлицо3));
	КонецЕсли;
	Если ЗначениеЗаполнено(Физлицо4) Тогда 
		СписокФизлиц.Добавить(ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, Физлицо4));
	КонецЕсли;
	Если ЗначениеЗаполнено(Физлицо5) Тогда 
		СписокФизлиц.Добавить(ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, Физлицо5));
	КонецЕсли;
	Если ЗначениеЗаполнено(Физлицо6) Тогда 
		СписокФизлиц.Добавить(ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, Физлицо6));
	КонецЕсли;
	Если ЗначениеЗаполнено(Физлицо7) Тогда 
		СписокФизлиц.Добавить(ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, Физлицо7));
	КонецЕсли;
	Если ЗначениеЗаполнено(Физлицо8) Тогда 
		СписокФизлиц.Добавить(ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, Физлицо8));
	КонецЕсли;
	Если ЗначениеЗаполнено(Физлицо9) Тогда 
		СписокФизлиц.Добавить(ОбщегоНазначенияКлиентСервер.ПолучитьРеквизитФормыПоПути(Форма, Физлицо9));
	КонецЕсли;
	
	КадровыеДанныеФизическихЛиц = КадровыйУчет.КадровыеДанныеФизическихЛиц(Истина, СписокФизлиц, "ИОФамилия");
	
	ИОФамилии = Новый Массив;
	Для Каждого Физлицо Из СписокФизлиц Цикл
		СтрокаФизлица = КадровыеДанныеФизическихЛиц.Найти(Физлицо, "ФизическоеЛицо");
		Если СтрокаФизлица <> Неопределено Тогда
			ИОФамилии.Добавить(СтрокаФизлица.ИОФамилия);
		КонецЕсли	
	КонецЦикла;		
	
	Если ИОФамилии.Количество() > 0 Тогда
		Группа.ЗаголовокСвернутогоОтображения = ЗаголовокСвернутогоОтображенияГруппы(НСтр("ru = 'Подписи'"), ИОФамилии);
	Иначе	
		Группа.ЗаголовокСвернутогоОтображения = НСтр("ru = 'Подписи не указаны'");
	КонецЕсли	
	
КонецПроцедуры

Функция ЗаголовокСвернутогоОтображенияГруппы(Знач ЗаголовокГруппы, ОтображаемыеЗначения, Знач ПредставлениеНезаполненного = Неопределено, Знач ПредставлениеЧастичноЗаполненного = Неопределено)
	
	Если ПредставлениеНезаполненного = Неопределено Тогда
		ПредставлениеНезаполненного = НСтр("ru = '<не указано>'")
	КонецЕсли;	
	Если ПредставлениеЧастичноЗаполненного = Неопределено Тогда
		ПредставлениеЧастичноЗаполненного = НСтр("ru = '(не все поля заполнены)'")	
	КонецЕсли;	
	
	ПредставляемыеЗначения = Новый Массив;
	Для Каждого ОтображаемоеЗначение Из ОтображаемыеЗначения Цикл
		Если ЗначениеЗаполнено(ОтображаемоеЗначение) Тогда
			ПредставляемыеЗначения.Добавить(ОтображаемоеЗначение);
		КонецЕсли	
	КонецЦикла;
	
	Если ПредставляемыеЗначения.Количество() = 0 Тогда
		ПредставлениеЗначений = ПредставлениеНезаполненного;
	Иначе
		ПредставлениеЗначений = СтроковыеФункцииКлиентСервер.СтрокаИзМассиваПодстрок(ПредставляемыеЗначения, ", ", Истина);
		Если ПредставляемыеЗначения.Количество() < ОтображаемыеЗначения.Количество() Тогда
			ПредставлениеЗначений = ПредставлениеЗначений + " " + ПредставлениеЧастичноЗаполненного
		КонецЕсли	
	КонецЕсли;	
	
	Возврат ЗаголовокГруппы + ?(ЗначениеЗаполнено(ЗаголовокГруппы) И ЗначениеЗаполнено(ПредставлениеЗначений), ": ", "") + ПредставлениеЗначений;
	
КонецФункции

Функция ФормаЭлемента(Элемент)
	Родитель = Элемент.Родитель;
	Пока ТипЗнч(Родитель) <> Тип("УправляемаяФорма") Цикл
		Родитель = Родитель.Родитель
	КонецЦикла;	
	Возврат Родитель
КонецФункции

#КонецОбласти

#Область УпорядочиваниеСписоковСотрудниковДокументов

// Дополняет состав запрашиваемых кадровых данных именами, которые необходимы
// для организации упорядочивания
//
// Параметры:
//		КадровыеДанные	- Строка, имена кадровых данных сотрудника, перечисленные через запятую
//						- Массив, строк имен кадровых данных сотрудника
//
// Возвращаемое значение:
//		Булево - Итсина, если кадровые данные были дополнены полями порядка
//
Функция ДополнитьКадровымиДаннымиНастрокиПорядкаСписка(КадровыеДанные) Экспорт

	ПоляДобавлены = Ложь;
	ПоляУпорядочивания = РегистрыСведений.ДополнительныеНастройкиЗарплатаКадры.ПоляУпорядочиванияСпискаСотрудников();
		
	Если ПоляУпорядочивания.Количество() > 0 Тогда
		
		Если ТипЗнч(КадровыеДанные) = Тип("Строка") Тогда
			ЗапрашиваемыеКадровыеДанные = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(КадровыеДанные);
		Иначе
			ЗапрашиваемыеКадровыеДанные = КадровыеДанные;
		КонецЕсли;
		
		Для каждого ОписаниеПоляУпорядочивания Из ПоляУпорядочивания Цикл
			
			Если ОписаниеПоляУпорядочивания.КлючПорядка = "Справочник.ПодразделенияОрганизаций" Тогда
				ИмяКадровыхДанных = "Подразделение";
			ИначеЕсли ОписаниеПоляУпорядочивания.КлючПорядка = "Справочник.Должности" Тогда
				ИмяКадровыхДанных = "Должность";
			ИначеЕсли ОписаниеПоляУпорядочивания.КлючПорядка = "Справочник.Сотрудники" Тогда
				ИмяКадровыхДанных = ОписаниеПоляУпорядочивания.ПолеПорядка;
			Иначе
				ИмяКадровыхДанных = "";
			КонецЕсли; 
			
			Если Не ПустаяСтрока(ИмяКадровыхДанных) Тогда
				
				Если ЗапрашиваемыеКадровыеДанные.Найти(ИмяКадровыхДанных) = Неопределено Тогда
					
					ПоляДобавлены = Истина;
					Если ТипЗнч(КадровыеДанные) = Тип("Строка") Тогда
						КадровыеДанные = ?(ПустаяСтрока(КадровыеДанные), "", КадровыеДанные + ",") + ИмяКадровыхДанных;
					Иначе
						КадровыеДанные.Добавить(ИмяКадровыхДанных);
					КонецЕсли;
					ЗапрашиваемыеКадровыеДанные.Добавить(ИмяКадровыхДанных);
					
				КонецЕсли; 
				
			КонецЕсли; 
			
		КонецЦикла;		
		
	КонецЕсли; 
	
	Возврат ПоляДобавлены;
	
КонецФункции

// Модифицирует текст последнего звпроса в тексте, преданного запроса, изменяет или добавляет
// поля упорядочивания выборки запроса
//
// Параметры:
//		Запрос									- Запрос
//		ПсевдонимВТКадровыеДанныеСотрудников	- Строка, имя таблицы, которая содержит поля упорядочивания
//
Процедура ДополнитьТекстЗапросаУпорядочиваниемСпискаСотрудников(Запрос, ПсевдонимВТКадровыеДанныеСотрудников) Экспорт
	
	ПоляУпорядочивания = РегистрыСведений.ДополнительныеНастройкиЗарплатаКадры.ПоляУпорядочиванияСпискаСотрудников();
	Если ПоляУпорядочивания.Количество() > 0  Тогда
		
		ТекстыЗапросов = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Запрос.Текст, ";");
		ТекстПоследнегоЗапроса = ТекстыЗапросов[ТекстыЗапросов.Количество() - 1];
		
		СхемаЗапроса = Новый СхемаЗапроса;
		СхемаЗапроса.УстановитьТекстЗапроса(ТекстПоследнегоЗапроса);
		
		ПакетЗапросов = СхемаЗапроса.ПакетЗапросов[0];
		
		ИндексПоляПорядка = 0;
		ПсевдонимыДобавленныхПолей = Новый Соответствие;
		ПоляПорядка = Новый Массив;
		
		Для каждого ОписаниеПоляУпорядочивания Из ПоляУпорядочивания Цикл
			
			Если ОписаниеПоляУпорядочивания.КлючПорядка = "Справочник.ПодразделенияОрганизаций" Тогда
				ПутьКДанным = "ВЫРАЗИТЬ(КадровыеДанныеСотрудников.Подразделение КАК Справочник.ПодразделенияОрганизаций)." + ОписаниеПоляУпорядочивания.ПолеПорядка;
				ИмяПоляПорядка = "Подразделение";
			ИначеЕсли ОписаниеПоляУпорядочивания.КлючПорядка = "Справочник.Должности" Тогда
				ПутьКДанным = "ВЫРАЗИТЬ(КадровыеДанныеСотрудников.Должность КАК Справочник.Должности)." + ОписаниеПоляУпорядочивания.ПолеПорядка;
				ИмяПоляПорядка = "Должность";
			ИначеЕсли ОписаниеПоляУпорядочивания.КлючПорядка = "Справочник.Сотрудники" Тогда
				ПутьКДанным = "КадровыеДанныеСотрудников." + ОписаниеПоляУпорядочивания.ПолеПорядка;
				ИмяПоляПорядка = ОписаниеПоляУпорядочивания.ПолеПорядка;
			Иначе
				ПутьКДанным = "";
			КонецЕсли; 
			
			Если Не ПустаяСтрока(ПутьКДанным) Тогда
				
				ПутьКДанным = СтрЗаменить(ПутьКДанным, "КадровыеДанныеСотрудников.", ПсевдонимВТКадровыеДанныеСотрудников + ".");
				Для каждого ОператорСхемы Из ПакетЗапросов.Операторы Цикл
					
					Для каждого ИсточникСхемы Из ОператорСхемы.Источники Цикл
						
						Если ИсточникСхемы.Источник.Псевдоним = ПсевдонимВТКадровыеДанныеСотрудников Тогда
							
							ДобавлятьДоступноеПоле = Истина;
							Для каждого ДоступноеПоле Из ИсточникСхемы.Источник.ДоступныеПоля Цикл
								Если ДоступноеПоле.Имя = ИмяПоляПорядка Тогда
									ДобавлятьДоступноеПоле = Ложь;
									Прервать;
								КонецЕсли; 
							КонецЦикла; 
							
							Если ДобавлятьДоступноеПоле Тогда
								ИсточникСхемы.Источник.ДоступныеПоля.Добавить(ИмяПоляПорядка);
							КонецЕсли; 
							
							Прервать;
							
						КонецЕсли; 
						
					КонецЦикла; 
					
					ОператорСхемы.ВыбираемыеПоля.Добавить(ПутьКДанным);
					
					КолонкаПорядка = ПакетЗапросов.Колонки.Получить(ПакетЗапросов.Колонки.Количество() - 1);
					КолонкаПорядка.Псевдоним = "ПолеПорядка" + ИндексПоляПорядка;
						
					Если ПсевдонимыДобавленныхПолей.Получить(КолонкаПорядка.Псевдоним) = Неопределено Тогда
						ПсевдонимыДобавленныхПолей.Вставить(КолонкаПорядка.Псевдоним, Истина);
						ПоляПорядка.Вставить(0, КолонкаПорядка);
					КонецЕсли; 
					
				КонецЦикла;
				
			КонецЕсли; 
			
			ИндексПоляПорядка = ИндексПоляПорядка + 1;
			
		КонецЦикла;		
		
		Если ПоляПорядка.Количество() > 0 Тогда
			
			Для каждого КолонкаПорядка Из ПоляПорядка Цикл
				
				ПакетЗапросов.Порядок.Добавить(КолонкаПорядка);
				
				КоличествоПолейПорядка = ПакетЗапросов.Порядок.Количество();
				ПакетЗапросов.Порядок.Сдвинуть(КоличествоПолейПорядка - 1, 0);
					
			КонецЦикла;
			
			Запрос.Текст = СтрЗаменить(Запрос.Текст, ТекстПоследнегоЗапроса, СхемаЗапроса.ПолучитьТекстЗапроса());
			
		КонецЕсли; 
		
	КонецЕсли; 
	
КонецПроцедуры

#КонецОбласти

#Область УниверсальныеПроцедуры

// Заполняет данные выбора справочника при вводе по строке и автоподборе в справочнике.
// Предназначена для вызова из обработчика ОбработкаПолученияДанныхВыбора в том случае, когда 
// обработка получения данных выбора выполняется "особым образом" (с выполнением особенного запроса).
//
// Параметры:
//		ДанныеВыбора
//		МетаданныеОбъекта - метаданные справочника для которого переопределяется обработка получения данных выбора.
//		Отбор - параметры отбора, переданные в ОбработкаПолученияДанныхВыбора.
//		Запрос - Запрос с предустановленными параметрами текст запроса, который необходимо выполнять
//			ВНИМАНИЕ. Запрос обязательно должен быть построен по схеме:
//				ВЫБРАТЬ * 
//				ИЗ 
//					... КАК <Псевдоним>
//				...
//			Текст запроса дополняется необходимыми функциями.
//		ПсевдонимТаблицы - псевдоним основной таблицы в тексте переданного запроса.
//
Процедура ЗаполнитьДанныеВыбораСправочника(ДанныеВыбора, МетаданныеОбъекта, Параметры, Запрос, ПсевдонимТаблицы) Экспорт
	
	ЗапросТекст = Запрос.Текст;
	
	ЗапросТекст = СтрЗаменить(ЗапросТекст, " *", 
	" ПЕРВЫЕ 51
	|	" + ПсевдонимТаблицы + ".Ссылка,
	|	" + ПсевдонимТаблицы + ".ПометкаУдаления,
	|	" + ПсевдонимТаблицы + ".Код,
	|	" + ПсевдонимТаблицы + ".Наименование");
	
	Если МетаданныеОбъекта.ДлинаКода = 0 Тогда
		ЗапросТекст = СтрЗаменить(ЗапросТекст, ",
		|	" + ПсевдонимТаблицы + ".Код", "");
	КонецЕсли;
	
	Если МетаданныеОбъекта.ДлинаНаименования = 0 Тогда
		ЗапросТекст = СтрЗаменить(ЗапросТекст, ",
		|	" + ПсевдонимТаблицы + ".Наименование", "");
	Иначе 
		ЗапросТекст = ЗапросТекст + "
		|
		|УПОРЯДОЧИТЬ ПО
		|	Наименование";
	КонецЕсли;
	
	КоличествоЭлементов = 51;
	ДанныеВыбора = Новый СписокЗначений;
	
	ДополнительноеУсловие = "";
	
	Если Параметры.Свойство("Отбор") Тогда
		Для Каждого ЭлементОтбора Из Параметры.Отбор Цикл
			Реквизит = МетаданныеОбъекта.Реквизиты.Найти(ЭлементОтбора.Ключ);
			Если Реквизит <> НеОпределено Тогда
				Если ТипЗнч(ЭлементОтбора.Значение) = Тип("Массив") Тогда
					ДополнительноеУсловие = "
					|	И " + ПсевдонимТаблицы + "." + ЭлементОтбора.Ключ + " В (&" + ЭлементОтбора.Ключ + ")";
				Иначе
					ДополнительноеУсловие = "
					|	И " + ПсевдонимТаблицы + "." + ЭлементОтбора.Ключ + " = &" + ЭлементОтбора.Ключ;
				КонецЕсли;	
				Запрос.УстановитьПараметр(ЭлементОтбора.Ключ, ЭлементОтбора.Значение);
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	ПоляПредставления = ПоляПредставления(МетаданныеОбъекта);
	
	Если Параметры.Свойство("СтрокаПоиска") 
		И НЕ ПустаяСтрока(Параметры.СтрокаПоиска) Тогда
		
		Для Каждого Поле Из МетаданныеОбъекта.ВводПоСтроке Цикл
			ТекстЗапроса = ЗапросТекст;
			
			ИмяПоля = Поле.Имя;
			
			// Установим в запросе условие.
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "И &ДополнительноеУсловие", ДополнительноеУсловие + "
			|И " + ПсевдонимТаблицы + "." + ИмяПоля + " ПОДОБНО &СтрокаПоиска");
			Запрос.УстановитьПараметр("СтрокаПоиска", Параметры.СтрокаПоиска + "%");

			// Допишем в поля выборки поле поиска.
			Если ИмяПоля <> ПоляПредставления.ПолеОсновногоПредставления 
				И ИмяПоля <> ПоляПредставления.ПолеДопПредставления Тогда
				ТекстЗапроса = СтрЗаменить(ТекстЗапроса, " ПЕРВЫЕ 51", " ПЕРВЫЕ 51
				|	" + ПсевдонимТаблицы + "." + ИмяПоля + " КАК ПолеПоиска,");
			КонецЕсли;
			
			// Установим число выбираемых элементов.
			ТекстЗапроса = СтрЗаменить(ТекстЗапроса, " ПЕРВЫЕ 51", " ПЕРВЫЕ " + Строка(КоличествоЭлементов));
			
			Запрос.Текст = ТекстЗапроса;
			Выборка = Запрос.Выполнить().Выбрать();
			Пока Выборка.Следующий() Цикл
				Представление = ПредставлениеВыбираемогоЭлемента(Выборка, ПоляПредставления, ИмяПоля);
				
				МассивСтрок = Новый Массив();
				ВыделеннаяСтрока 		= Новый ФорматированнаяСтрока(Лев(Представление, СтрДлина(Параметры.СтрокаПоиска)), Новый Шрифт( , , Истина), WebЦвета.Зеленый);
				ОкончаниеПредставления 	= Прав(Представление, СтрДлина(Представление) - СтрДлина(Параметры.СтрокаПоиска));
				СтрокаПредставление = Новый ФорматированнаяСтрока(ВыделеннаяСтрока, ОкончаниеПредставления);
				
				ДанныеВыбора.Добавить(Выборка.Ссылка, СтрокаПредставление);				
			КонецЦикла;
			КоличествоЭлементов = КоличествоЭлементов - Выборка.Количество();
			Если КоличествоЭлементов <= 0 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
	Иначе
		// Установим в запросе условие.
		ЗапросТекст = СтрЗаменить(ЗапросТекст, "И &ДополнительноеУсловие", ДополнительноеУсловие);
		
		Запрос.Текст = ЗапросТекст;
		Выборка = Запрос.Выполнить().Выбрать();
		Пока Выборка.Следующий() Цикл
			Представление = ПредставлениеВыбираемогоЭлемента(Выборка, ПоляПредставления);
			ДанныеВыбора.Добавить(Выборка.Ссылка, Представление);
		КонецЦикла;
		
	КонецЕсли;
	
	ДанныеВыбора.СортироватьПоПредставлению();

КонецПроцедуры

// Создает структуру наборов записей, имитирующую коллекцию движений регистратора.
// Может применяться для временного использования методов, формирующих движения, 
// когда регистратор пока не записан.
//
// Параметры:
//	МетаданныеРегистратора
//
// Возвращаемое значение - структура, где ключ имя набора, 
//		значение - набор записей с отбором по временной ссылке.
//
Функция НаборыЗаписейРегистратора(МетаданныеРегистратора, ВременнаяСсылка = Неопределено, ПропуститьПроверкуЗапретаИзменения = Истина, ЭтоВременныйНаборЗаписей = Истина) Экспорт
	
	НаборыЗаписей = Новый Структура;
	
	Если ВременнаяСсылка = Неопределено Тогда
		ВременнаяСсылка = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(МетаданныеРегистратора.ПолноеИмя()).ПолучитьСсылку();
	КонецЕсли;
	
	Для Каждого МетаданныеНабора Из МетаданныеРегистратора.Движения Цикл
		Менеджер = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(МетаданныеНабора.ПолноеИмя());
		НаборЗаписей = Менеджер.СоздатьНаборЗаписей();
		НаборЗаписей.Отбор.Регистратор.Установить(ВременнаяСсылка);
		НаборЗаписей.Записывать = Истина;
		Если ПропуститьПроверкуЗапретаИзменения Тогда
			НаборЗаписей.ДополнительныеСвойства.Вставить("ПропуститьПроверкуЗапретаИзменения");
		КонецЕсли;
		Если ЭтоВременныйНаборЗаписей Тогда
			НаборЗаписей.ДополнительныеСвойства.Вставить("ЭтоВременныйНаборЗаписей");
			НаборЗаписей.ДополнительныеСвойства.Вставить("ОтключитьМеханизмРегистрацииОбъектов");
			НаборЗаписей.ОбменДанными.Получатели.АвтоЗаполнение = Ложь;
		КонецЕсли;
		НаборыЗаписей.Вставить(МетаданныеНабора.Имя, НаборЗаписей);
	КонецЦикла;
	
	Возврат НаборыЗаписей;
	
КонецФункции

/////////////////////////////////////////////////////////////////////////////////////////
// Особенные математические функции подгонки сумм.

// По "округленной" сумме многих слагаемых округляет сами слагаемые,
// внося при этом наименьшую ошибку округления
// Примечание. "Округленная" сумма не обязательно должна быть равна 
// 				выражению Окр(сумма слагаемых), может быть получена  
//              из других соображений.
//
// Параметры:
//		Данные - Таблица значений
//		ИмяКолонки - строка - имя колонки, содержащей слагаемые.
//		Сумма - Число
//		Точность - Число - необязательный, по умолчанию - рубли.
//      ИмяКлюча - строка - перечень колонок, однозначно определяющих строку из т.з. Данные.
//
Процедура ОкруглитьСлагаемыеПоСумме(Данные, ИмяКолонки, Сумма, Точность = 0, ИмяКлюча = "ФизическоеЛицо") Экспорт 
	
	ВременнаяТаблица = Данные.Скопировать(, ИмяКлюча + "," + ИмяКолонки);
	ВременнаяТаблица.Колонки.Добавить(ИмяКолонки + "Окр");
	Для каждого СтрокаТЗ Из ВременнаяТаблица Цикл
		СтрокаТЗ[ИмяКолонки + "Окр"] = Окр(СтрокаТЗ[ИмяКолонки],Точность)
	КонецЦикла;
	Данные.ЗагрузитьКолонку(ВременнаяТаблица.ВыгрузитьКолонку(ИмяКолонки + "Окр"),ИмяКолонки);
	
	СуммаСлагаемых = ВременнаяТаблица.Итог(ИмяКолонки + "Окр");
	Если СуммаСлагаемых <> Сумма Тогда
		Шаг = Pow(10, -Точность);
		РасхождениеСуммы = Сумма - СуммаСлагаемых;
		Приращение = ?(РасхождениеСуммы > 0, Шаг, -Шаг);
		ВсегоПриращений = Мин(РасхождениеСуммы / Приращение, ВременнаяТаблица.Количество());
		ВременнаяТаблица.Колонки.Добавить(ИмяКолонки + "Расхождение");
		ВременнаяТаблица.Колонки.Добавить(ИмяКолонки + "Изменение");
		Для каждого СтрокаТЗ Из ВременнаяТаблица Цикл
			СтрокаТЗ[ИмяКолонки + "Расхождение"] = ?(СтрокаТЗ[ИмяКолонки + "Окр"] < СтрокаТЗ[ИмяКолонки], СтрокаТЗ[ИмяКолонки] - СтрокаТЗ[ИмяКолонки + "Окр"], СтрокаТЗ[ИмяКолонки + "Окр"] - СтрокаТЗ[ИмяКолонки]);
			СтрокаТЗ[ИмяКолонки + "Изменение"] = ?(СтрокаТЗ[ИмяКолонки + "Окр"] < СтрокаТЗ[ИмяКолонки], - Шаг, Шаг);
		КонецЦикла;
		ВременнаяТаблица.Сортировать(ИмяКолонки + "Изменение" + ?(Приращение > 0,""," Убыв") + ", " + ИмяКолонки + "Расхождение Убыв");
		СтруктураПоиска = Новый Структура(ИмяКлюча); 
		Для Сч = 1 По ВсегоПриращений Цикл
			Если ВременнаяТаблица[Сч-1][ИмяКолонки + "Изменение"] <> Приращение Тогда
				ЗаполнитьЗначенияСвойств(СтруктураПоиска, ВременнаяТаблица[Сч-1]);
				Данные.НайтиСтроки(СтруктураПоиска)[0][ИмяКолонки] = ВременнаяТаблица[Сч-1][ИмяКолонки + "Окр"] + Приращение;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры

// По округленной сумме двух слагаемых округляет сами слагаемые, внося при этом наименьшую ошибку округления.
//
// Параметры:
//		ПервоеСлагаемое - Число
//		ВтороеСлагаемое - Число
//		Сумма - Число - необязательный, если не указана определяется по переданным слагаемым.
//		Точность - Число - необязательный, по умолчанию - рубли.
//
Процедура ОкруглитьДваСлагаемыхПоСумме(ПервоеСлагаемое, ВтороеСлагаемое, Сумма = Неопределено, Точность = 0) Экспорт
	
	Если Сумма = Неопределено Тогда
		Сумма = Окр(ПервоеСлагаемое + ВтороеСлагаемое, Точность)
	КонецЕсли;
	
	Если Окр(ПервоеСлагаемое, Точность) + Окр(ВтороеСлагаемое, Точность) = Сумма Тогда
		ПервоеСлагаемое = Окр(ПервоеСлагаемое, Точность);
		ВтороеСлагаемое = Окр(ВтороеСлагаемое, Точность);
	Иначе
		РасхождениеСуммы = Сумма - Окр(ПервоеСлагаемое, Точность) - Окр(ВтороеСлагаемое, Точность);
		ПервоеРасхождение = ?(Окр(ПервоеСлагаемое, Точность) < ПервоеСлагаемое, ПервоеСлагаемое - Окр(ПервоеСлагаемое, Точность), Окр(ПервоеСлагаемое, Точность) - ПервоеСлагаемое);
		ВтороеРасхождение = ?(Окр(ВтороеСлагаемое, Точность) < ВтороеСлагаемое, ВтороеСлагаемое - Окр(ВтороеСлагаемое, Точность), Окр(ВтороеСлагаемое, Точность) - ВтороеСлагаемое);
		ПервоеСлагаемое = Окр(ПервоеСлагаемое, Точность);
		ВтороеСлагаемое = Окр(ВтороеСлагаемое, Точность);
		Если ПервоеРасхождение <= ВтороеРасхождение Тогда
			ВтороеСлагаемое = ВтороеСлагаемое + РасхождениеСуммы; 
		Иначе
			ПервоеСлагаемое = ПервоеСлагаемое + РасхождениеСуммы; 
		КонецЕсли;
	КонецЕсли;

КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Замена ссылок по информационной базе.

// Принимает Соответствие между замещаемыми ссылками и заменителями и заменяет ссылки по информационной базе.
Процедура ЗаменитьСсылки(ПарыЗамен) Экспорт
	КешПолей = Новый Соответствие;
	ДвиженияССубконтоИмя =
		?(Метаданные.ВариантВстроенногоЯзыка = Метаданные.СвойстваОбъектов.ВариантВстроенногоЯзыка.Английский,
		".RecordsWithExtDimensions",
		".ДвиженияССубконто");
	
	ЗаменяемыеСсылки = Новый Массив;
	Для Каждого Пара Из ПарыЗамен Цикл
		ЗаменяемыеСсылки.Добавить(Пара.Ключ);
	КонецЦикла;
	РезультатыПоиска = НайтиПоСсылкам(ЗаменяемыеСсылки);
	МаксимальныйИндекс = РезультатыПоиска.Количество() - 1;
	// (.Ссылка: исходная ссылка; .Данные: ссылающийся объект; .Метаданные: метаданные ссылающегося объекта).
	
 	Для Каждого Результат Из РезультатыПоиска Цикл
		Замещаемое = Результат.Ссылка;
		// Объект, ссылающийся сам на себя не трогаем.
		Если Замещаемое = Результат.Данные Тогда
			Продолжить;
		КонецЕсли;

		ТипЗамещаемого = ТипЗнч(Замещаемое);
		Заменитель = ПарыЗамен[Результат.Ссылка];

		Если ЭтоСсылочныйОбъектМетаданных(Результат.Метаданные) Тогда
			// обработка самого объекта
			ОбъектДанных = Результат.Данные.ПолучитьОбъект();
			ИменаПолей = ИменаПолейСТипом(Результат.Метаданные.ПолноеИмя(), ТипЗамещаемого, КешПолей, "Ссылка, Ref");
			ЗаменитьЗначение(ОбъектДанных, ИменаПолей, Замещаемое, Заменитель);
			// Обработка табчастей объекта.
			Для Каждого ТабЧасть Из Результат.Метаданные.ТабличныеЧасти Цикл
				ИменаПолей = ИменаПолейСТипом(Результат.Метаданные.ПолноеИмя()+"."+ТабЧасть.Имя, ТипЗамещаемого, КешПолей, "Ссылка, Ref");
				Для Каждого ТабСтрока Из ОбъектДанных[ТабЧасть.Имя] Цикл
					ЗаменитьЗначение(ТабСтрока, ИменаПолей, Замещаемое, Заменитель);
				КонецЦикла;
			КонецЦикла;
			// Обработка стандартных табчастей объекта.
			Если Метаданные.ПланыСчетов.Содержит(Результат.Метаданные) Или Метаданные.ПланыВидовРасчета.Содержит(Результат.Метаданные) Тогда
				Для Каждого ТабЧасть Из Результат.Метаданные.СтандартныеТабличныеЧасти Цикл
					ИменаПолей = ИменаПолейСТипом(Результат.Метаданные.ПолноеИмя()+"."+ТабЧасть.Имя, ТипЗамещаемого, КешПолей, "Ссылка, Ref");
					Для Каждого ТабСтрока Из ОбъектДанных[ТабЧасть.Имя] Цикл
						ЗаменитьЗначение(ТабСтрока, ИменаПолей, Замещаемое, Заменитель);
					КонецЦикла;
				КонецЦикла;
			КонецЕсли;
			ЗаписатьДанные(ОбъектДанных);
			ОбъектДанных = Неопределено;
			// Обработка движений документа.
			Если Метаданные.Документы.Содержит(Результат.Метаданные) Тогда
				Для Каждого Движение Из Результат.Метаданные.Движения Цикл
					ДопТаблица = "";
					Если Метаданные.РегистрыНакопления.Содержит(Движение) Тогда
						Регистр = РегистрыНакопления[Движение.Имя];
					ИначеЕсли Метаданные.РегистрыСведений.Содержит(Движение) Тогда
						Регистр = РегистрыСведений[Движение.Имя];
					ИначеЕсли Метаданные.РегистрыБухгалтерии.Содержит(Движение) Тогда
						ДопТаблица = ДвиженияССубконтоИмя;
						Регистр = РегистрыБухгалтерии[Движение.Имя];
					ИначеЕсли Метаданные.РегистрыРасчета.Содержит(Движение) Тогда
						Регистр = РегистрыРасчета[Движение.Имя];
					КонецЕсли;
					ИменаПолей = ИменаПолейСТипом(Движение.ПолноеИмя() + ДопТаблица, ТипЗамещаемого, КешПолей, "Регистратор, Recorder");
					Набор = НаборЗаписей(Регистр, Новый Структура("Регистратор", Результат.Данные));
					ЗначениеЗаменено = Ложь;
					Для Каждого Запись Из Набор Цикл
						ЗаменитьЗначение(Запись, ИменаПолей, Замещаемое, Заменитель, ЗначениеЗаменено);
					КонецЦикла;
					ЗаписатьДанные(Набор, ЗначениеЗаменено);
				КонецЦикла;
				// Обработка последовательностей, включающих документ.
				Для Каждого Последовательность Из Метаданные.Последовательности Цикл
					Если Последовательность.Документы.Содержит(Результат.Метаданные) Тогда
						ИменаПолей = ИменаПолейСТипом(Последовательность.ПолноеИмя(), ТипЗамещаемого, КешПолей, "Регистратор, Recorder");
						Набор = НаборЗаписей(Последовательности[Последовательность.Имя], Новый Структура("Регистратор", Результат.Данные));
						Для Каждого Запись Из Набор Цикл
							ЗаменитьЗначение(Запись, ИменаПолей, Замещаемое, Заменитель);
						КонецЦикла;
						ЗаписатьДанные(Набор);
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		// константы
		ИначеЕсли Метаданные.Константы.Содержит(Результат.Метаданные) Тогда
			Константы[Результат.Метаданные.Имя].Установить(Заменитель);
		// Регистры сведений (необъектные таблицы).
		ИначеЕсли Метаданные.РегистрыСведений.Содержит(Результат.Метаданные) Тогда
			ИменаПолей = ИменаПолейСТипом(Результат.Метаданные.ПолноеИмя(), ТипЗамещаемого, КешПолей);
			Отборы = ОтборыРегистраСведений(Результат.Метаданные, Результат.Данные);
			Набор = НаборЗаписей(РегистрыСведений[Результат.Метаданные.Имя], Отборы);
			// Сохраняем старую запись набора и очищаем саму запись в БД.
			Таблица = Набор.Выгрузить();
			Набор.Очистить();
			ЗаписатьДанные(Набор);
			// Заменяем значение в сохраненной записи и пишем ее в БД.
			ЗаменитьЗначение(Таблица[0], ИменаПолей, Замещаемое, Заменитель);
			Для Каждого ИмяПоля Из ИменаПолей Цикл
				Если Отборы.Свойство(ИмяПоля) И Отборы[ИмяПоля] = Замещаемое Тогда
					Набор.Отбор[ИмяПоля].Установить(Заменитель);
				КонецЕсли
			КонецЦикла;
			Набор.Загрузить(Таблица);
			ЗаписатьДанные(Набор);
			// Заменим значение в таких же ключах записей следующих результатов поиска.
			ИндексРезультата = РезультатыПоиска.Индекс(Результат);
			Для ИндексСледующего = ИндексРезультата + 1 По МаксимальныйИндекс Цикл
				Следующий = РезультатыПоиска[ИндексСледующего];
				Если ТипЗнч(Следующий.Данные) = ТипЗнч(Результат.Данные) Тогда
					СледующийСовпадает = Ложь;
					// Определяемся, что найденный ключ такой же, как обработанный.
					Для Каждого Отбор Из Отборы Цикл
						СледующийСовпадает = (Следующий.Данные[Отбор.Ключ] = Отбор.Значение);
						Если Не СледующийСовпадает Тогда
							Прервать;
						КонецЕсли;
					КонецЦикла;
					// Меняем значение в совпадающем ключе записи.
					Если СледующийСовпадает Тогда
						Для Каждого Отбор Из Отборы Цикл
							Если Следующий.Данные[Отбор.Ключ] = Замещаемое Тогда
								Следующий.Данные[Отбор.Ключ] = Заменитель;
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
			// все
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Возвращает признак того, что объект метаданных является неразделенными основными данными
// (т.е. не входит в состав разделителя ОбластьДанныхОсновныеДанные.
//
// Параметры:
// ОбъектМетаданных - метаданные объекта.
//
// Возвращаемое значение:
// Булево.
//
Функция ЭтоОбщиеДанные(ОбъектМетаданных) Экспорт
	Возврат Метаданные.ОбщиеРеквизиты.ОбластьДанныхОсновныеДанные.Состав.Найти(ОбъектМетаданных).Использование = Метаданные.СвойстваОбъектов.ИспользованиеОбщегоРеквизита.НеИспользовать
КонецФункции	

// Возвращает признак того, что объект метаданных может изменяться в режиме АРМ.
//
// Параметры:
// ОбъектМетаданных - метаданные объекта.
//
// Возвращаемое значение:
// Булево.
//
Функция АвтономнаяРаботаРазрешеноИзменениеДанных(ОбъектМетаданных) Экспорт
	
	ТолькоПросмотр = Ложь;
	АвтономнаяРаботаСлужебный.ОпределитьВозможностьИзмененияДанных(ОбъектМетаданных, ТолькоПросмотр);
	
	Возврат НЕ ТолькоПросмотр
	
КонецФункции	

#Область ПостроительМеню

// Возвращает описание раздела меню.
//
// Параметры:
//			ВидЭлемента - значения системных перечислений:
//						ВидГруппыФормы.Подменю
//						ВидГруппыФормы.ГруппаКнопок.
//			Заголовок
//
// ВозвращаемоеЗначение:
//			Структура - дополняет структуру, полученную с помощью метода ЭлементМеню
//					ключем Пункты - Массив.
//
Функция РазделМеню(Заголовок = "") Экспорт
	
	ОписаниеРазделаМеню = ЭлементМеню(ВидГруппыФормы.Подменю, Заголовок);
	ОписаниеРазделаМеню.Вставить("Пункты", Новый Массив);
	
	Возврат ОписаниеРазделаМеню;
	
КонецФункции

// Возвращает описание разделителя кнопок меню.
//
Функция РазделительМеню() Экспорт
	
	Возврат ЭлементМеню();
	
КонецФункции

// Возвращает описание раздела пункта меню.
//
// Параметры:
//			Заголовок
//			ИмяКоманды
//			Действие
//
// ВозвращаемоеЗначение:
//			Структура - дополняет структуру, полученную с помощью метода ЭлементМеню
//					ключами ИмяКоманды и Действие.
//
Функция ПунктМеню(Заголовок = "", ИмяКоманды = "", Действие = "") Экспорт
	
	ОписаниеПунктаМеню = ЭлементМеню(ВидКнопкиФормы.КнопкаКоманднойПанели, Заголовок);
	ОписаниеПунктаМеню.Вставить("ИмяКоманды", ИмяКоманды);
	ОписаниеПунктаМеню.Вставить("Действие", Действие); 
	
	Возврат ОписаниеПунктаМеню;
	
КонецФункции

// Осуществляет установку меню командных панелей формы, по приведенному описанию. Добавляет команды
// элементы меню в командные панели формы.
//
// Параметры:
//			Форма
//			ОписаниеМеню - структура описания меню, полученная с помощью методов
//							РазделМеню и ПунктМеню.
//			ИменаКонтейнеров - имена элементов (групп командной панели), в которых
//							необходимо разместить меню, перечисленные через запятую.
//
Процедура УстановитьМенюВФорме(Форма, ОписаниеМеню, ИменаКонтейнеров) Экспорт
	
	Если ОписаниеМеню = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	
	ИменаГруппПодменю = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИменаКонтейнеров);
	
	Для каждого ИмяГруппыПодменю Из ИменаГруппПодменю Цикл
		
		ГруппаПодменю = Форма.Элементы.Найти(ИмяГруппыПодменю);
		Если ГруппаПодменю = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		// Предварительная очистка меню, при повторном заполнении.
		Если ГруппаПодменю <> Неопределено Тогда
			Пока ГруппаПодменю.ПодчиненныеЭлементы.Количество() > 0 Цикл
				Форма.Элементы.Удалить(ГруппаПодменю.ПодчиненныеЭлементы[0]);
			КонецЦикла; 
		КонецЕсли; 
		
		Если ОписаниеМеню.Вид = ВидГруппыФормы.Подменю Тогда
			
			ДобавитьПодменю(Форма, ОписаниеМеню, ГруппаПодменю);
			
		ИначеЕсли ОписаниеМеню.Вид = ВидКнопкиФормы.КнопкаКоманднойПанели Тогда
			
			ДобавитьПунктМеню(Форма, ОписаниеМеню, ГруппаПодменю);
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Проверяет доступность объектов метаданных по полным именам. Проверка производится по критериям:
//	- наличие объекта в конфигурации
//  - доступность в зависимости от значений функциональных опций в состав которых входит объект
//  - и наличие права на объект у текущего пользователя.
//
// Параметры:
//		ПолныеИменаОбъектовМетаданных - Массив строк (например: "Документы.ПриемНаРаботу").
//		ПравоДоступа - Строка, описание параметра соответствует описанию параметра "Право" метода
//				платформы "ПравоДоступа".
//		ПолныеИменаИсключаемыхИзПроверкиОбъектовМетаданных - Массив строк имен объектов метаданных,
//				право доступа к которым не предоставляется из логических соображений.
//
// ВозвращаемоеЗначение:
//		Соответствие - Ключ - полное имя объекта метаданных, Значение - Синоним объекта, заданный в конфигураторе.
//
Функция ПредставленияДоступныхОбъектовМетаданных(ПолныеИменаОбъектовМетаданных, ПравоДоступа, ПолныеИменаИсключаемыхИзПроверкиОбъектовМетаданных = Неопределено) Экспорт
	
	ПредставленияДоступныхОбъектов = Новый Соответствие;
	
	Для каждого ПолноеИмяОбъектаМетаданных Из ПолныеИменаОбъектовМетаданных Цикл
		
		Если ПустаяСтрока(ПолноеИмяОбъектаМетаданных) Тогда
			Продолжить;
		КонецЕсли; 
		
		Если ПолныеИменаИсключаемыхИзПроверкиОбъектовМетаданных <> Неопределено
			И ПолныеИменаИсключаемыхИзПроверкиОбъектовМетаданных.Найти(ПолноеИмяОбъектаМетаданных) <> Неопределено Тогда
			Продолжить;
		КонецЕсли; 
		
		ЧастиИменОбъекта = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмяОбъектаМетаданных, ".");
		ОбъектМетаданных = Метаданные[ЧастиИменОбъекта[0]].Найти(ЧастиИменОбъекта[1]);
		
		Если ОбъектМетаданных = Неопределено Тогда
			Продолжить;
		КонецЕсли; 
				
		Если НЕ ОбщегоНазначения.ОбъектМетаданныхДоступенПоФункциональнымОпциям(ОбъектМетаданных) Тогда
			Продолжить;
		КонецЕсли;
				
		Если НЕ ПравоДоступа(ПравоДоступа, ОбъектМетаданных) Тогда
			Продолжить;
		КонецЕсли;
		
		ПредставленияДоступныхОбъектов.Вставить(ПолноеИмяОбъектаМетаданных, ОбъектМетаданных.Синоним);
		
	КонецЦикла;
	
	Возврат ПредставленияДоступныхОбъектов;
	
КонецФункции

#КонецОбласти

// Проверяет принадлежность объекта метаданных к подсистемам. Проверка производится на вхождение
// в состав указанных подсистем и на вхождение в состав подсистем подчиненных указанным.
//
// Параметры:
//			ПолноеИмяОбъектаМетаданных 	- Строка, полное имя объекта метаданных (см. функцию НайтиПоПолномуИмени).
//			ИменаПодсистем				- Строка, имена подсистем, перечисленные через запятую.
//
// Возвращаемое значение:
//		Булево
//
Функция ОбъектМетаданныхВключенВПодсистемы(ПолноеИмяОбъектаМетаданных, ИменаПодсистем) Экспорт
	
	ЭтоОбъектПодсистемы = Ложь;
	
	МетаданныеОбъекта = Метаданные.НайтиПоПолномуИмени(ПолноеИмяОбъектаМетаданных);
	Если МетаданныеОбъекта <> Неопределено Тогда
		
		МассивИменПодсистем = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИменаПодсистем);
		Для каждого ИмяПодсистемы Из МассивИменПодсистем Цикл
			
			МетаданныеПодсистемы = Метаданные.Подсистемы.Найти(ИмяПодсистемы);
			Если МетаданныеПодсистемы <> Неопределено Тогда
				ЭтоОбъектПодсистемы = ОбъектМетаданныхВключенВПодсистему(МетаданныеПодсистемы, МетаданныеОбъекта);
			КонецЕсли; 
			
			Если ЭтоОбъектПодсистемы Тогда
				Прервать;
			КонецЕсли; 
			
		КонецЦикла;
		
	КонецЕсли; 
	
	Возврат ЭтоОбъектПодсистемы;
	
КонецФункции

// Проверяет вхождение объекта метаданных в подсистему. Рекурсивно проверяется вхождение
// объекта метаданных в подсистемы подчиненные указанной.
//
// Параметры:
//		МетаданныеПодсистемы	- Метаданные подсистемы.
//		МетаданныеОбъекта		- Метаданные объекта.
//
// Возвращаемое значение:
//		Булево
//
Функция ОбъектМетаданныхВключенВПодсистему(МетаданныеПодсистемы, МетаданныеОбъекта)
	
	ВходитВСостав = МетаданныеПодсистемы.Состав.Содержит(МетаданныеОбъекта);
	Если НЕ ВходитВСостав Тогда
		
		Для каждого МетаданныеПодчиненнойПодсистемы Из МетаданныеПодсистемы.Подсистемы Цикл
			
			ВходитВСостав = ОбъектМетаданныхВключенВПодсистему(МетаданныеПодчиненнойПодсистемы, МетаданныеОбъекта);
			Если ВходитВСостав Тогда
				Прервать;
			КонецЕсли; 
			
		КонецЦикла;
		
	КонецЕсли; 
	
	Возврат ВходитВСостав;
	
КонецФункции

// Возвращает значение по умолчанию для типа соответствующего типу переданного параметра.
//
// Параметры:
//		Значение			- Любое значение.
//
// Возвращаемое значение:
//		Пустое значение такого же типа как и значение переданное в качестве параметра.
//
Функция ПустоеЗначениеТипаПоЗначению(Значение)
	Тип = ТипЗнч(Значение);
	ОписаниеТипа = Новый ОписаниеТипов(ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Тип));
	Возврат ОписаниеТипа.ПривестиЗначение();
КонецФункции

#КонецОбласти

#Область КлючевыеРеквизитыЗаполненияФормы

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции для предупреждения об очистке таблиц формы при редактировании "ключевых" реквизитов.
//
// Для работы механизма в форме должны быть определены экспортные процедуры: 
// 		КлючевыеРеквизитыЗаполненияФормыТаблицыОчищаемыеПриИзменении()
// 		КлючевыеРеквизитыЗаполненияФормыОписаниеКлючевыхРеквизитов().
// Пример можно посмотреть в форме документа НачислениеЗарплаты.
//

// Процедура заполняет текст предупреждения при редактировании для ключевых реквизитов.
Процедура КлючевыеРеквизитыЗаполненияФормыЗаполнитьПредупреждения(Форма, МассивОписанийРеквизитов = Неопределено, ДействиеПриИзмененииОчистка = Истина) Экспорт
	
	Если МассивОписанийРеквизитов = Неопределено Тогда 
		МассивОписанийРеквизитов = Форма.КлючевыеРеквизитыЗаполненияФормыОписаниеКлючевыхРеквизитов();
	КонецЕсли;	
	
	Для Каждого Описание Из МассивОписанийРеквизитов Цикл
		Если Описание.Свойство("ПредупреждениеПриРедактировании") Тогда
			ПредупреждениеПриРедактировании = Описание.ПредупреждениеПриРедактировании;
		Иначе
			ПредупреждениеПриРедактировании = КлючевыеРеквизитыПредставлениеПредупреждения(Описание.Представление, ДействиеПриИзмененииОчистка)
		КонецЕсли;
		ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(
		Форма.Элементы,
		Описание.ЭлементФормы,
		"ПредупреждениеПриРедактировании",
		ПредупреждениеПриРедактировании);
	КонецЦикла;
	
КонецПроцедуры

Функция КлючевыеРеквизитыЗаполненияФормыТекстПредупрежденияДокументовСАвтоматическимРасчетом() Экспорт
	Возврат Нстр("ru = 'Ручные исправления таблиц документа будут потеряны'");
КонецФункции

// Функция возвращает текст предупреждения для конкретного реквизита.
Функция КлючевыеРеквизитыПредставлениеПредупреждения(ПредставлениеРеквизита, ДействиеПриИзмененииОчистка)
	
	ПредставлениеПредупреждения = НСтр("ru = 'Редактирование %1 приведет к %2 табличных частей документа'");
	
	Если ДействиеПриИзмененииОчистка Тогда
		ПредставлениеДействияПриИзменении = Нстр("ru = 'очистке'");
	Иначе 
		ПредставлениеДействияПриИзменении = Нстр("ru = 'перезаполнению'");
	КонецЕсли;
	
	ПредставлениеПредупреждения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(ПредставлениеПредупреждения, ПредставлениеРеквизита, ПредставлениеДействияПриИзменении);
	
	Возврат	ПредставлениеПредупреждения;
	
КонецФункции 

#КонецОбласти

#Область РасчетПериодовСостоянийСотрудников

// Возвращает пустую структуру для описания регистра первичных данных.
//
// Возвращаемое значение:
//	Структура - структура с полями:
//		ИмяРегистра - имя регистра сведений содержащего первичные данные.
//		ИмяПоляНачало - Дата - имя поля, содержащего дату начала интервала.
//		ИмяПоляОкончание - Дата - имя поля, содержащего дату окончания интервала.
//		ИмяПоляПриоритет - ПеречислениеСсылка.СостоянияСотрудника - имя поля, содержащего состояние сотрудника.
//							Исходя из значения этого поля определяется приоритет интервала.
//		Измерения - Массив - сюда надо добавить поля - измерения, в разрезе которых ведется учет.
//		Ресурсы - Массив - сюда надо добавить поля - ресурсы.
//
Функция ОписаниеРегистраИсходныхПериодовСостояний() Экспорт 
	Описание = Новый Структура;
	Описание.Вставить("ИмяРегистра");
	Описание.Вставить("ИмяПоляДатаНачалаСобытия");
	Описание.Вставить("ИмяПоляДатаНачалаПериода");
	Описание.Вставить("ИмяПоляДатаОкончанияПериода");
	Описание.Вставить("ИмяПоляПриоритет");          
	Описание.Вставить("Измерения", Новый Массив);
	Описание.Вставить("Ресурсы", Новый Массив);

	Возврат Описание;
КонецФункции	

// Возвращает пустую структуру для описания регистра вторичных данных.
//
// Возвращаемое значение:
//	Структура - структура с полями:
//		ИмяРегистра - имя регистра сведений содержащего вторичные данные.
//		ИмяПоляНачало - Дата - имя поля, содержащего дату начала интервала.
//		ИмяПоляОкончание - Дата - имя поля, содержащего дату окончания интервала.
//		Измерения - Массив - сюда надо добавить поля - измерения, в разрезе которых ведется учет.
//		Ресурсы - Массив - сюда надо добавить поля - ресурсы.
//
Функция ОписаниеРегистраРассчитанныхПериодовСостояний() Экспорт 
	Описание = Новый Структура;
	Описание.Вставить("ИмяРегистра");
	Описание.Вставить("ИмяПоляДатаНачалаПериода");
	Описание.Вставить("ИмяПоляДатаОкончанияПериода");
	Описание.Вставить("Измерения", Новый Массив);
	Описание.Вставить("Ресурсы", Новый Массив);

	Возврат Описание;
КонецФункции	

// Обновляет данные вторичного регистра учета событий на оси времени
// с учетом приоритетов.
//
// 	Параметры: 
//		ОписаниеРегистраПервичныхДанных - структура см. СтруктураОписанияРегистраПервичныхДанных - содержит описание
//		                                  регистра первичных данных.
//		ОписаниеРегистраВторичныхДанных	структура см. СтруктураОписанияРегистраВторичныхДанных - содержит описание регистра
//		вторичных данных.
//      ЗначенияИзмерений - таблица значений - содержит данные для отбора. Имена колонок совпадают с имена измерений
//                          регистра первичных данных.
//		РежимЗагрузки - булево - устанавливает свойство ОбменДанными.Загрузка набору записей регистра вторичных данных.
//
Процедура ОбновитьРегистрРассчитанныхПериодовСостояний(ОписаниеРегистраПервичныхДанных, ОписаниеРегистраВторичныхДанных, ЗначенияИзмерений, РежимЗагрузки = Ложь) Экспорт
	
	Если ЗначенияИзмерений <> Неопределено 
		И ЗначенияИзмерений.Количество() = 0 Тогда
		
		Возврат;
	КонецЕсли;
	
	СтруктураПоискаВТаблицеФильтра = Новый Структура;
	Для Каждого Колонка Из ЗначенияИзмерений.Колонки Цикл
		СтруктураПоискаВТаблицеФильтра.Вставить(Колонка.Имя);		
	КонецЦикла;	
	
	ТаблицаДанныхПервичногоРегистра = ТаблицаИсходныхДанныхСостояний(ОписаниеРегистраПервичныхДанных);
	
	ВыборкаДанныхПервичногоРегистра = ВыборкаИсходныхДанныхСостояний(ОписаниеРегистраПервичныхДанных, ЗначенияИзмерений);
	
	ЗначенияИзмеренийПредыдущейЗаписи = Неопределено;
	Пока ВыборкаДанныхПервичногоРегистра.Следующий() Цикл
		Если ЗначенияИзмеренийПредыдущейЗаписи = Неопределено Тогда
			ЗначенияИзмеренийПредыдущейЗаписи = ЗначенияИзмеренийПериодовСостояний(ОписаниеРегистраПервичныхДанных);						
		ИначеЕсли ЗначенияИзмеренийЗаписейСостоянийОтличны(ЗначенияИзмеренийПредыдущейЗаписи, ВыборкаДанныхПервичногоРегистра) Тогда
			ДанныеВторичногоРегистра = РассчитанныеПериодыСостояний(ТаблицаДанныхПервичногоРегистра, ОписаниеРегистраПервичныхДанных);	
			ЗаписатьНаборРегистраРассчитанныхПериодовСостояний(ЗначенияИзмеренийПредыдущейЗаписи, ОписаниеРегистраВторичныхДанных, ДанныеВторичногоРегистра);	
			ТаблицаДанныхПервичногоРегистра.Очистить();
			
			Если ЗначенияИзмерений <> Неопределено Тогда
				ЗаполнитьЗначенияСвойств(СтруктураПоискаВТаблицеФильтра, ЗначенияИзмеренийПредыдущейЗаписи);
				СтрокиТаблицыОтбора = ЗначенияИзмерений.НайтиСтроки(СтруктураПоискаВТаблицеФильтра);
				Для Каждого УдаляемаяСтрока Из СтрокиТаблицыОтбора Цикл
					ЗначенияИзмерений.Удалить(УдаляемаяСтрока);
				КонецЦикла;
			КонецЕсли;	
				
		КонецЕсли;	
		
		СтрокаТаблицы = ТаблицаДанныхПервичногоРегистра.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицы, ВыборкаДанныхПервичногоРегистра);
		
		ЗаполнитьЗначенияСвойств(ЗначенияИзмеренийПредыдущейЗаписи, ВыборкаДанныхПервичногоРегистра);
	КонецЦикла;		
	
	Если ТаблицаДанныхПервичногоРегистра.Количество() > 0 Тогда
		ДанныеВторичногоРегистра = РассчитанныеПериодыСостояний(ТаблицаДанныхПервичногоРегистра, ОписаниеРегистраПервичныхДанных);	
		
		ЗаписатьНаборРегистраРассчитанныхПериодовСостояний(
			ЗначенияИзмеренийПредыдущейЗаписи,
			ОписаниеРегистраВторичныхДанных,
			ДанныеВторичногоРегистра,
			РежимЗагрузки);
			
			Если ЗначенияИзмерений <> Неопределено Тогда
				ЗаполнитьЗначенияСвойств(СтруктураПоискаВТаблицеФильтра, ЗначенияИзмеренийПредыдущейЗаписи);
				СтрокиТаблицыОтбора = ЗначенияИзмерений.НайтиСтроки(СтруктураПоискаВТаблицеФильтра);

				Для Каждого УдаляемаяСтрока Из СтрокиТаблицыОтбора Цикл
					ЗначенияИзмерений.Удалить(УдаляемаяСтрока);
				КонецЦикла;
			КонецЕсли;	
	КонецЕсли;	
		
	// По тем значениям измерений, по которым не было записей в регистре первичных данных 
	// запишем пустые наборы.
	
	Если ЗначенияИзмерений <> Неопределено Тогда 
		Для Каждого ИзмеренияПустогоНабора Из ЗначенияИзмерений Цикл
			СтруктураЗначенийИзмерений = ЗначенияИзмеренийПериодовСостояний(ОписаниеРегистраПервичныхДанных);
			ЗаполнитьЗначенияСвойств(СтруктураЗначенийИзмерений, ИзмеренияПустогоНабора);
			
			ЗаписатьНаборРегистраРассчитанныхПериодовСостояний(СтруктураЗначенийИзмерений, ОписаниеРегистраВторичныхДанных);
				
		КонецЦикла;	
	КонецЕсли;			
КонецПроцедуры

Процедура ЗарегистрироватьСторноИсходныхДанныхСостояний(Движения, ИмяРегистраПервичныхДанных, ДокументСсылка, СторнируемыйДокумент) Экспорт
	СторнируемыйНабор = РегистрыСведений[ИмяРегистраПервичныхДанных].СоздатьНаборЗаписей();
	СторнируемыйНабор.Отбор.Регистратор.Установить(СторнируемыйДокумент);
	СторнируемыйНабор.Прочитать();
	
	НаборСторноЗаписей = Движения[ИмяРегистраПервичныхДанных];
	
	Для Каждого СторнируемаяЗапись Из СторнируемыйНабор Цикл
		Если Не СторнируемаяЗапись.Сторно Тогда
			СторноЗапись = НаборСторноЗаписей.Добавить();
			ЗаполнитьЗначенияСвойств(СторноЗапись, СторнируемаяЗапись);
			СторноЗапись.ДокументОснование = ДокументСсылка;
			СторноЗапись.Сторно = Истина;
			СторноЗапись.Регистратор = ДокументСсылка;
		КонецЕсли;	
	КонецЦикла;	
		
	Движения[ИмяРегистраПервичныхДанных].Записывать = Истина;
	
КонецПроцедуры	


#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ФАЙЛАМИ ОТЧЕТНОСТИ

// Процедура создает и записывает файл, содержащий сведения для отправки в ПФР.
// 
// Параметры:
// 		ИмяФайла - строка
//  	ТекстФайла - строка
//		РасширениеЗаглавнымиБуквами - булево, необязательный.
//		Кодировка - необязательный, кодировка записываемого файла по умолчанию "windows-1251".
//		
Функция ЗаписатьФайлОтчетностиНаДиск(ИмяФайла, ТекстФайла, РасширениеЗаглавнымиБуквами = Истина, Кодировка = Неопределено) Экспорт
	
	ТекстовыйДокумент = Новый ТекстовыйДокумент;
	ТекстовыйДокумент.УстановитьТекст(ТекстФайла);
	
	Если РасширениеЗаглавнымиБуквами Тогда
		ПолноеИмяФайла = ПолучитьИмяВременногоФайла("XML");
	Иначе 
		ПолноеИмяФайла = ПолучитьИмяВременногоФайла("xml");
	КонецЕсли;	
	
	Если Кодировка = Неопределено Тогда
		ТекстовыйДокумент.Записать(ПолноеИмяФайла, "windows-1251");
	Иначе
		ТекстовыйДокумент.Записать(ПолноеИмяФайла, Кодировка);
	КонецЕсли;	
	
	Возврат ПолноеИмяФайла;
КонецФункции	

// Процедура записывает файл отчетности в базу.
// 
// Параметры:
// 		ВладелецФайла - ссылка на объект - владелец файла.
// 		ИмяФайла - строка.
//  	ТекстФайла - строка
//		РасширениеЗаглавнымиБуквами - булево, необязательный.
//		Кодировка - необязательный, кодировка записываемого файла по умолчанию "windows-1251".
//
Процедура ЗаписатьФайлВАрхив(ВладелецФайла, Знач ИмяФайла, ТекстФайла, РасширениеЗаглавнымиБуквами = Истина, Кодировка = Неопределено) Экспорт
	УстановитьПривилегированныйРежим(Истина);
	
	ИмяОбъекта = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ВладелецФайла.Метаданные().ПолноеИмя(), ".")[1];
	
	ПолноеИмяФайла = ЗаписатьФайлОтчетностиНаДиск(ИмяФайла, ТекстФайла, РасширениеЗаглавнымиБуквами, Кодировка);
	
	Файл = Новый Файл(ПолноеИмяФайла);
	
	ДвоичныеДанныеФайла = Новый ДвоичныеДанные(ПолноеИмяФайла);
	
	АдресВременногоХранилищаФайла = ПоместитьВоВременноеХранилище(ДвоичныеДанныеФайла);
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("ВладелецФайла", ВладелецФайла);
	
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ПрисоединенныеФайлы.Ссылка
	|ИЗ
	|	ИсточникДанных КАК ПрисоединенныеФайлы
	|ГДЕ
	|	ПрисоединенныеФайлы.ВладелецФайла = &ВладелецФайла";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ИсточникДанных", "Справочник." + ИмяОбъекта + "ПрисоединенныеФайлы"); 
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда 
		Если РасширениеЗаглавнымиБуквами Тогда
			Расширение = ВРег(Прав(Файл.Расширение, СтрДлина(Файл.Расширение)-1));
		Иначе
			Расширение = Прав(Файл.Расширение, СтрДлина(Файл.Расширение)-1);
		КонецЕсли;	
		
		ИнформацияОФайле = Новый Структура("ДатаМодификацииУниверсальная, АдресФайлаВоВременномХранилище, АдресВременногоХранилищаТекста, Расширение",
										Файл.ПолучитьУниверсальноеВремяИзменения(),
										АдресВременногоХранилищаФайла,
										"",
										Прав(Файл.Расширение, СтрДлина(Файл.Расширение)-1));
		
		ПрисоединенныеФайлы.ОбновитьПрисоединенныйФайл(Выборка.Ссылка, ИнформацияОФайле);	
		
		ФайлОбъект = Выборка.Ссылка.ПолучитьОбъект();
		ФайлОбъект.Наименование = Лев(ИмяФайла, СтрДлина(ИмяФайла) - 4);
		ФайлОбъект.Записать();
	Иначе
		
		Если РасширениеЗаглавнымиБуквами Тогда
			Расширение = ВРег(ОбщегоНазначенияКлиентСервер.РасширениеБезТочки(Файл.Расширение));
		Иначе
			Расширение = ОбщегоНазначенияКлиентСервер.РасширениеБезТочки(Файл.Расширение);
		КонецЕсли;	
		
		ВремяИзменения = ТекущаяДатаСеанса();
		ВремяИзмененияУниверсальное = Файл.ПолучитьУниверсальноеВремяИзменения();
				
		ПрисоединенныйФайл = ПрисоединенныеФайлы.ДобавитьФайл(
			ВладелецФайла,
			Лев(ИмяФайла, СтрДлина(ИмяФайла) - 4),
			Расширение,
			ВремяИзменения,
			ВремяИзмененияУниверсальное,
			АдресВременногоХранилищаФайла,
			"");
	КонецЕсли;	
	
	УдалитьФайлы(ПолноеИмяФайла);
		
КонецПроцедуры

// Возвращает данные присоединенного к объекту файла.
//
// Параметры:	
//		СсылкаНаОбъект - ссылка на объект - владелец файла.
//		УникальныйИдентификатор - необязательный. Уникальный идентификатор формы, передается в том случае,
//				   если данные файла нужно поместить во временное хранилище формы.
//  ПолучатьСсылкуНаДвоичныеДанные - Булево - начальное значение Истина,
//                 если передать Ложь, то ссылка на двоичные данные не будет получена,
//                 что существенно ускорит выполнение для больших двоичных данных.
//
//	Возвращаемое значение:
//		см. ПрисоединенныеФайлы.ПолучитьДанныеФайла	
//		
Функция ПолучитьДанныеФайла(СсылкаНаОбъект, УникальныйИдентификатор = Неопределено, ПолучатьСсылкуНаДвоичныеДанные = Истина) Экспорт
	ИмяОбъекта = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СсылкаНаОбъект.Метаданные().ПолноеИмя(), ".")[1];
	
	УстановитьПривилегированныйРежим(Истина);
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Ссылка", СсылкаНаОбъект);
	
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	ПрисоединенныеФайлы.Ссылка
	|ИЗ
	|	ИсточникДанных КАК ПрисоединенныеФайлы
	|ГДЕ
	|	ПрисоединенныеФайлы.ВладелецФайла = &Ссылка";
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ИсточникДанных", "Справочник." + ИмяОбъекта + "ПрисоединенныеФайлы"); 
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		СсылкаНаФайл = Выборка.Ссылка;
	Иначе
		Возврат Неопределено;
	КонецЕсли;	
			
	Возврат ПрисоединенныеФайлы.ПолучитьДанныеФайла(СсылкаНаФайл, УникальныйИдентификатор, ПолучатьСсылкуНаДвоичныеДанные);	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции работы с данными физических лиц.

// Создает временную таблицу, содержащую ФИО физических лиц, содержащую колонки:
//		* ФизическоеЛицо
//		* Дата
//		* Ссылка
//		* Фамилия
//		* Имя
//		* Отчество
//		* ФИОПолные
//		* РасшифровкаПодписи
//
// Параметры:
//		МенеджерВременныхТаблиц
//		ТолькоРазрешенные
//		ИменаПолейОтветственныхЛиц	- Строка, содержит имена полей временной таблицы, разделенные запятыми, в которых
//		                             содержатся ответственные лица.
//									- Массив, строк имен полей временной таблицы, в которой содержатся ответственные лица
//											поле должно содержать ссылку на справочник ФизическиеЛица.
//		ИмяВременнойТаблицыДанныхДокумента - Строка, имя временной таблицы, содержащей данные документа,
//						таблица, должна содержать колонки:
//							* Дата -  дата на которую получаются ФИО.
//							* Ссылка - нечто, которое можно использовать для отбора полученных данных.
//
Процедура СоздатьВТФИООтветственныхЛиц(МенеджерВременныхТаблиц, ТолькоРазрешенные, ИменаПолейОтветственныхЛиц, ИмяВременнойТаблицыДанныхДокумента) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	
	Если ТипЗнч(ИменаПолейОтветственныхЛиц) = Тип("Строка") Тогда
		МассивИменПолей = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИменаПолейОтветственныхЛиц,,,Истина);
	Иначе
		МассивИменПолей = ИменаПолейОтветственныхЛиц;
	КонецЕсли;

	ЭтоПервоеПолеОтветственного = Истина;
	Для Каждого ИмяПоляОтветственногоЛица Из МассивИменПолей Цикл
		
		Если Не ЭтоПервоеПолеОтветственного Тогда 
			Запрос.Текст = Запрос.Текст + "
										  |ОБЪЕДИНИТЬ ВСЕ
										  |ВЫБРАТЬ РАЗЛИЧНЫЕ";
		Иначе
										  
			Запрос.Текст = Запрос.Текст + "ВЫБРАТЬ " + ?(ТолькоРазрешенные, "РАЗРЕШЕННЫЕ", "") + " РАЗЛИЧНЫЕ";
		КонецЕсли;										  
		
		Запрос.Текст = Запрос.Текст + "
		                              |	ДанныеДокумента.ИмяПоляОтветственногоЛица КАК ФизическоеЛицо,
		                              |	ДанныеДокумента.Дата КАК Период,
									  |	ДанныеДокумента.Ссылка" + ?(ЭтоПервоеПолеОтветственного, "
									  |ПОМЕСТИТЬ ВТСотрудники", "") + "
		                              |ИЗ
		                              |	ДанныеДокумента КАК ДанныеДокумента";	
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "ИмяПоляОтветственногоЛица", ИмяПоляОтветственногоЛица);
		
		ЭтоПервоеПолеОтветственного = Ложь;	
		
	КонецЦикла;		
	
	Запрос.Текст = СтрЗаменить(Запрос.Текст, "ДанныеДокумента", ИмяВременнойТаблицыДанныхДокумента);
	Запрос.Выполнить();
	
	ОписательВременныхТаблиц = КадровыйУчет.ОписательВременныхТаблицДляСоздатьВТКадровыеДанныеФизическихЛиц(
		МенеджерВременныхТаблиц, "ВТСотрудники");
		
	КадровыйУчет.СоздатьВТКадровыеДанныеФизическихЛиц(ОписательВременныхТаблиц, ТолькоРазрешенные, "Фамилия,Имя,Отчество,ФИОПолные,ИОФамилия");
	
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗРЕШЕННЫЕ РАЗЛИЧНЫЕ
	|	ДанныеДокументов.ФизическоеЛицо,
	|	ДанныеДокументов.Период КАК Дата,
	|	ДанныеДокументов.Ссылка,
	|	КадровыеДанныеФизЛиц.Фамилия,
	|	КадровыеДанныеФизЛиц.Имя,
	|	КадровыеДанныеФизЛиц.Отчество,
	|	КадровыеДанныеФизЛиц.ФИОПолные,
	|	КадровыеДанныеФизЛиц.ИОФамилия КАК РасшифровкаПодписи
	|ПОМЕСТИТЬ ВТФИООтветственныхЛиц
	|ИЗ
	|	ВТСотрудники КАК ДанныеДокументов
	|		ЛЕВОЕ СОЕДИНЕНИЕ ВТКадровыеДанныеФизическихЛиц КАК КадровыеДанныеФизЛиц
	|		ПО ДанныеДокументов.ФизическоеЛицо = КадровыеДанныеФизЛиц.ФизическоеЛицо
	|			И ДанныеДокументов.Период = КадровыеДанныеФизЛиц.Период";
				   
	Если НЕ ТолькоРазрешенные Тогда
		Запрос.Текст = СтрЗаменить(Запрос.Текст, "ВЫБРАТЬ РАЗРЕШЕННЫЕ", "ВЫБРАТЬ");
	КонецЕсли;	

	Запрос.Выполнить();			   
	
КонецПроцедуры	

///////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции ЗАРПЛАТА И КАДРЫ.

// Получает размер минимальной оплаты труда.
//
// Параметры:
//	ДатаАктуальности - дата, на которую нужно получить МРОТ.
//
// Возвращаемое значение:
//	число, размер МРОТ на дату, или Неопределено, если МРОТ на дату не определен
//
Функция МинимальныйРазмерОплатыТрудаРФ(ДатаАктуальности) Экспорт
	
	Возврат ЗарплатаКадрыПовтИсп.МинимальныйРазмерОплатыТрудаРФ(ДатаАктуальности);
	
КонецФункции	

// Заполняет документ по основанию сотрудник, осуществляет проверку корректности ввода документа.
// В случае , когда проверка не проходит вызывает исключение.
//
// Параметры:
//		ДокументОбъект - ДокументОбъект
//		ДанныеЗаполнения - СправочникСсылка.Сотрудники
//		ПроверкаОформленностиНаРаботу 	- Булево, когда Истина вызывает исключение, если сотрудник уже принят на работу,
//											Ложь - если сотрудник еще не принят.
//		ОтключитьПроверкуЗанятости 		- Булево, отключает проверку принятости сотрудника.
//		ТолькоГоловнаяОрганизация		- Булево, указывает, что организация может быть только головной.
//
// Возвращаемое значение - Булево, Истина - ДанныеЗаполнения заполнен имеют тип СправочникСсылка.Сотрудники, Ложь -
// если  ДанныеЗаполнения содержат значение другого типа.
//
Процедура ЗаполнитьПоОснованиюСотрудником(ДокументОбъект, ДанныеЗаполнения, ПроверкаОформленностиНаРаботу = Ложь, ОтключитьПроверкуЗанятости = Ложь, ТолькоГоловнаяОрганизация = Ложь) Экспорт
	
	КадровыеДанные =  КадровыйУчет.КадровыеДанныеСотрудников(Истина, ДанныеЗаполнения, "ГоловнаяОрганизация,Организация,ФизическоеЛицо,ДатаПриема,ОформленПоТрудовомуДоговору,ДатаУвольнения");
	Если КадровыеДанные.Количество() > 0 Тогда
		
		СтрокаДанных = КадровыеДанные[0];
		
		Если НЕ ОтключитьПроверкуЗанятости Тогда
			
			Если ПроверкаОформленностиНаРаботу Тогда
				
				Если СтрокаДанных.ОформленПоТрудовомуДоговору Тогда
					
					Если ЗначениеЗаполнено(СтрокаДанных.ДатаУвольнения) Тогда
						
						ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
							НСтр("ru = 'Сотрудник ""%1"" был оформлен на работу с %2, уволен %3'"),
							ДанныеЗаполнения,
							Формат(СтрокаДанных.ДатаПриема, "ДЛФ=DD"),
							Формат(СтрокаДанных.ДатаУвольнения, "ДЛФ=DD"));
						
					Иначе
						
						Если ЗначениеЗаполнено(СтрокаДанных.ДатаПриема) Тогда
							
							ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
								НСтр("ru = 'Сотрудник ""%1"" уже оформлен на работу с %2'"),
								ДанныеЗаполнения,
								Формат(СтрокаДанных.ДатаПриема, "ДЛФ=DD"));
							
						Иначе
								
							ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
								НСтр("ru = 'Сотрудник ""%1"" уже оформлен на работу'"),
								ДанныеЗаполнения);
							
						КонецЕсли;
						
					КонецЕсли;
					
				КонецЕсли; 
					
			Иначе
				
				Если НЕ ЗначениеЗаполнено(СтрокаДанных.Организация) Тогда
					
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Сотрудник ""%1"" не оформлен на работу'"),
						ДанныеЗаполнения);
					
				ИначеЕсли ЗначениеЗаполнено(СтрокаДанных.ДатаУвольнения) Тогда
						
					ВызватьИсключение СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
						НСтр("ru = 'Сотрудник ""%1"" уволен %2'"),
						ДанныеЗаполнения,
						Формат(СтрокаДанных.ДатаУвольнения, "ДЛФ=DD"));
					
				КонецЕсли;
					
			КонецЕсли;
			
		КонецЕсли; 
		
		Если ЗначениеЗаполнено(СтрокаДанных.Организация) И НЕ ТолькоГоловнаяОрганизация Тогда
			ДокументОбъект.Организация = СтрокаДанных.Организация;
		Иначе
			ДокументОбъект.Организация = СтрокаДанных.ГоловнаяОрганизация;
		КонецЕсли;
		
		МетаданныеДокумента = ДокументОбъект.Метаданные();
		
		РеквизитСотрудник = МетаданныеДокумента.Реквизиты.Найти("Сотрудник");
		Если РеквизитСотрудник <> Неопределено Тогда
			
			Если РеквизитСотрудник.Тип.СодержитТип(Тип("СправочникСсылка.ФизическиеЛица")) Тогда
				ДокументОбъект.Сотрудник 		= СтрокаДанных.ФизическоеЛицо;
			Иначе
				ДокументОбъект.Сотрудник 		= СтрокаДанных.Сотрудник;
			КонецЕсли;
			
		КонецЕсли; 
		
		Если МетаданныеДокумента.Реквизиты.Найти("ФизическоеЛицо") <> Неопределено Тогда
			
			ДокументОбъект.ФизическоеЛицо 	= СтрокаДанных.ФизическоеЛицо;
			
		КонецЕсли; 
		
	КонецЕсли;
	
КонецПроцедуры

// См. ПрефиксацияОбъектовПереопределяемый.ПолучитьПрефиксообразующиеРеквизиты.
//
Процедура ПолучитьПрефиксообразующиеРеквизиты(Объекты) Экспорт
	ЗарплатаКадрыВнутренний.ПолучитьПрефиксообразующиеРеквизиты(Объекты);
КонецПроцедуры

// См. ДатыЗапретаИзмененияПереопределяемый.ЗаполнитьИсточникиДанныхДляПроверкиЗапретаИзменения.
//
Процедура ЗаполнитьИсточникиДанныхДляПроверкиЗапретаИзменения(ИсточникиДанных) Экспорт
	ЗарплатаКадрыВнутренний.ЗаполнитьИсточникиДанныхДляПроверкиЗапретаИзменения(ИсточникиДанных);	
КонецПроцедуры

// См. ДатыЗапретаИзмененияПереопределяемый.ПередПроверкойЗапретаИзменения, проверяет
// дополнительное свойство объекта с ключом ОтключитьПроверкуДатыЗапретаИзменения. Если
// значение свойство Истина, проверка даты запрета изменения не производится.
//
Процедура ПередПроверкойЗапретаИзменения(Объект, ПроверкаЗапретаИзменения, УзелПроверкиЗапретаЗагрузки, СообщитьОЗапрете) Экспорт
	
	Если Объект.ДополнительныеСвойства.Свойство("ОтключитьПроверкуДатыЗапретаИзменения")
		И Объект.ДополнительныеСвойства.ОтключитьПроверкуДатыЗапретаИзменения Тогда
		
		ПроверкаЗапретаИзменения = Ложь;
		СообщитьОЗапрете = Ложь;
		
	КонецЕсли; 	
	
КонецПроцедуры

// Возвращает признак необходимости отключения бизнес логики при записи объекта.
//
// Параметры:
//  Объект - прикладной объект, например СправочникОбъект - объект для которого
//   требуется проверить необходимость отключения бизнес логики при записи.
//
// Возвращаемое значение:
//  Булево - признак необходимости отключения бизнес логики при записи объекта.
//
Функция ОтключитьБизнесЛогикуПриЗаписи(Знач Объект) Экспорт
	
	Возврат Объект.ОбменДанными.Загрузка И (НЕ Объект.ДополнительныеСвойства.Свойство("ПроверятьБизнесЛогикуПриЗаписи")); 
		
КонецФункции

#Область УправлениеОтборамиВФормахСДинамическимСписком

// Создает элементы формы для группы настроек отбора.
//		СписокНастройкиОтбораНадпись
//		НаименованиеРеквизитаФормыДинамическийСписок
//		ПараметрыКритерияОтбора
//
// Параметры:
//		Форма - Форма, где располагается динамический список
//		НаименованиеРеквизитаСписок - Наименование реквизита формы "Динамический список"
//		ГруппаНастроек - Наименование группы, где будут отображаться недоступные пользователю настройки отбора в динамическом списке
//		ПараметрыКритерияОтбора - структура имен параметров, указанных в тексте запроса динамического списка,
//									элементы для заполнения параметров будут выведены на форму
//									Ключ - имя параметра, Значение - описание типов параметра
//		ГруппаПараметровКритерияОтбора - Наименование группы, где будут выведены параметры критериев отбора
//		ИсключаемыеИменаОтборов - Строка - Имена отборов, исключаемых из надписи, разделенные запятой
//		ЗаполнятьПользовательскийОтборПоОрганизации - Булево - Если Истина, то пользовательский отбор по организации будет заполнен организацией по умолчанию
//
Процедура ПриСозданииНаСервереФормыСДинамическимСписком(Форма, НаименованиеРеквизитаСписок, ГруппаНастроек = "СписокНастройкиОтбора",
	ПараметрыКритерияОтбора = Неопределено, ГруппаПараметровКритерияОтбора = Неопределено, ИсключаемыеИменаОтборов = "", ЗаполнятьПользовательскийОтборПоОрганизации = Истина) Экспорт
	
	ГруппаНастроек = Форма.Элементы[ГруппаНастроек];
	Список = Форма[НаименованиеРеквизитаСписок];
	
	Элементы = Форма.Элементы;
	ДобавляемыеРеквизиты = Новый Массив;
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("СписокНастройкиОтбораНадпись", Новый ОписаниеТипов("Строка")));
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("НаименованиеРеквизитаФормыДинамическийСписок", Новый ОписаниеТипов("Строка")));
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("СинонимыЭлементовОтбора", Новый ОписаниеТипов("СписокЗначений")));
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ИспользоватьНесколькоОрганизацийЗарплатаКадрыБазовая", Новый ОписаниеТипов("Булево")));
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ИсключаемыеИменаОтборов", Новый ОписаниеТипов("Строка")));
	ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ЗаполнятьПользовательскийОтборПоОрганизации", Новый ОписаниеТипов("Булево")));
	
	Если ПараметрыКритерияОтбора <> Неопределено Тогда
		ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ПараметрыКритерияОтбора", Новый ОписаниеТипов("ТаблицаЗначений")));
		
		ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ИмяПараметра", Новый ОписаниеТипов("Строка"), "ПараметрыКритерияОтбора"));
		ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ТипПараметра", Новый ОписаниеТипов("ОписаниеТипов"), "ПараметрыКритерияОтбора"));
		ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ИмяРеквизитаФормыПараметра", Новый ОписаниеТипов("Строка"), "ПараметрыКритерияОтбора"));
		ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ИмяРеквизитаФормыПараметраИспользование", Новый ОписаниеТипов("Строка"), "ПараметрыКритерияОтбора"));
		ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ИмяЭлементаФормыПараметра", Новый ОписаниеТипов("Строка"), "ПараметрыКритерияОтбора"));
		ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы("ИмяЭлементаФормыПараметраИспользование", Новый ОписаниеТипов("Строка"), "ПараметрыКритерияОтбора"));
		
		ТаблицаПараметрыКритериевОтбора = Новый ТаблицаЗначений;
		ТаблицаПараметрыКритериевОтбора.Колонки.Добавить("ИмяПараметра", Новый ОписаниеТипов("Строка"));
		ТаблицаПараметрыКритериевОтбора.Колонки.Добавить("ТипПараметра", Новый ОписаниеТипов("ОписаниеТипов"));
		ТаблицаПараметрыКритериевОтбора.Колонки.Добавить("ИмяРеквизитаФормыПараметра", Новый ОписаниеТипов("Строка"));
		ТаблицаПараметрыКритериевОтбора.Колонки.Добавить("ИмяРеквизитаФормыПараметраИспользование", Новый ОписаниеТипов("Строка"));
		ТаблицаПараметрыКритериевОтбора.Колонки.Добавить("ИмяЭлементаФормыПараметра", Новый ОписаниеТипов("Строка"));
		ТаблицаПараметрыКритериевОтбора.Колонки.Добавить("ИмяЭлементаФормыПараметраИспользование", Новый ОписаниеТипов("Строка"));
		Для каждого ПараметрКритерияОтбора Из ПараметрыКритерияОтбора Цикл
			ИмяРеквизитаФормы = ПараметрКритерияОтбора.Ключ + "_" + СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "x");
			ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(ИмяРеквизитаФормы, ПараметрКритерияОтбора.Значение));
			
			НоваяСтрокаПараметра = ТаблицаПараметрыКритериевОтбора.Добавить();
			НоваяСтрокаПараметра.ИмяПараметра = ПараметрКритерияОтбора.Ключ;
			НоваяСтрокаПараметра.ТипПараметра = ПараметрКритерияОтбора.Значение;
			НоваяСтрокаПараметра.ИмяРеквизитаФормыПараметра = ИмяРеквизитаФормы;
			
			ИмяРеквизитаФормы = ПараметрКритерияОтбора.Ключ + "_Использование_" + СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "x");
			ДобавляемыеРеквизиты.Добавить(Новый РеквизитФормы(ИмяРеквизитаФормы, Новый ОписаниеТипов("Булево")));
			
			НоваяСтрокаПараметра.ИмяРеквизитаФормыПараметраИспользование = ИмяРеквизитаФормы;
		КонецЦикла;
	КонецЕсли;
	
	МассивИменРеквизитовФормы = Новый Массив;
	ЗарплатаКадры.ЗаполнитьМассивИменРеквизитовФормы(Форма, МассивИменРеквизитовФормы);
	ЗарплатаКадры.ИзменитьРеквизитыФормы(Форма, ДобавляемыеРеквизиты, МассивИменРеквизитовФормы);
	
	// Надпись отборов, не доспупных пользователю
	Если Элементы.Найти("СписокНастройкиОтбораНадпись") = Неопределено Тогда
		Элемент = Элементы.Добавить("СписокНастройкиОтбораНадпись", Тип("ПолеФормы"), ГруппаНастроек);
		Элемент.ПутьКДанным = "СписокНастройкиОтбораНадпись";
		Элемент.Вид = ВидПоляФормы.ПолеНадписи;
		Элемент.ПоложениеЗаголовка = ПоложениеЗаголовкаЭлементаФормы.Нет;
		Элемент.ЦветТекста = ЦветаСтиля.ПоясняющийТекст;
		Элемент.ЦветФона = ЦветаСтиля.ЦветФонаПодсказки;
	КонецЕсли;
	
	Если ПараметрыКритерияОтбора <> Неопределено И ГруппаПараметровКритерияОтбора <> Неопределено Тогда
		
		ГруппаПараметровКритерияОтбора = Форма.Элементы[ГруппаПараметровКритерияОтбора];
		ГруппаПараметровКритерияОтбора.Группировка = ГруппировкаПодчиненныхЭлементовФормы.Горизонтальная;
		ЛеваяГруппаПараметров = Неопределено;
		ПраваяГруппаПараметров = Неопределено;
		НомерПараметра = 0;
		Для каждого ПараметрКритерияОтбора Из ПараметрыКритерияОтбора Цикл
			НомерПараметра = НомерПараметра + 1;
			Если НомерПараметра/2 = Цел(НомерПараметра/2) Тогда
				Если ПраваяГруппаПараметров = Неопределено Тогда
					ИмяГруппы = "ПраваяГруппаПараметров" + "_" + СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "x");
					ПраваяГруппаПараметров = Элементы.Добавить(ИмяГруппы, Тип("ГруппаФормы"), ГруппаПараметровКритерияОтбора);
					ПраваяГруппаПараметров.Вид = ВидГруппыФормы.ОбычнаяГруппа;
					ПраваяГруппаПараметров.Отображение = ОтображениеОбычнойГруппы.Нет;
					ПраваяГруппаПараметров.ОтображатьЗаголовок = Ложь;
					ПраваяГруппаПараметров.Группировка = ГруппировкаПодчиненныхЭлементовФормы.Вертикальная;
				КонецЕсли;
				ГруппаТекущегоПараметра = ПраваяГруппаПараметров;
			Иначе
				Если ЛеваяГруппаПараметров = Неопределено Тогда
					ИмяГруппы = "ЛеваяГруппаПараметров" + "_" + СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "x");
					ЛеваяГруппаПараметров = Элементы.Добавить(ИмяГруппы, Тип("ГруппаФормы"), ГруппаПараметровКритерияОтбора);
					ЛеваяГруппаПараметров.Вид = ВидГруппыФормы.ОбычнаяГруппа;
					ЛеваяГруппаПараметров.Отображение = ОтображениеОбычнойГруппы.Нет;
					ЛеваяГруппаПараметров.ОтображатьЗаголовок = Ложь;
					ЛеваяГруппаПараметров.Группировка = ГруппировкаПодчиненныхЭлементовФормы.Вертикальная;
				КонецЕсли;
				ГруппаТекущегоПараметра = ЛеваяГруппаПараметров;
			КонецЕсли;
			
			ИмяГруппы = "ГруппаПараметра" + "_" + СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "x");
			ГруппаТекущегоПараметра = Элементы.Добавить(ИмяГруппы, Тип("ГруппаФормы"), ГруппаТекущегоПараметра);
			ГруппаТекущегоПараметра.Вид = ВидГруппыФормы.ОбычнаяГруппа;
			ГруппаТекущегоПараметра.Отображение = ОтображениеОбычнойГруппы.Нет;
			ГруппаТекущегоПараметра.ОтображатьЗаголовок = Ложь;
			ГруппаТекущегоПараметра.Группировка = ГруппировкаПодчиненныхЭлементовФормы.Горизонтальная;
			
			ИмяЭлементаФормы = ПараметрКритерияОтбора.Ключ + "_Использование_" + СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "x");
			СтрокаПараметра = ТаблицаПараметрыКритериевОтбора.Найти(ПараметрКритерияОтбора.Ключ, "ИмяПараметра");
			СтрокаПараметра.ИмяЭлементаФормыПараметраИспользование = ИмяЭлементаФормы;
			Элемент = Элементы.Добавить(ИмяЭлементаФормы, Тип("ПолеФормы"), ГруппаТекущегоПараметра);
			Элемент.ПутьКДанным = СтрокаПараметра.ИмяРеквизитаФормыПараметраИспользование;
			Элемент.Вид = ВидПоляФормы.ПолеФлажка;
			Элемент.Заголовок = ЗарплатаКадрыКлиентСервер.ПредставлениеИмениБезПробелов(ПараметрКритерияОтбора.Ключ);
			Элемент.УстановитьДействие("ПриИзменении", "Подключаемый_ПараметрКритерияОтбораПриИзменении");
			
			ИмяЭлементаФормы = ПараметрКритерияОтбора.Ключ + "_" + СтрЗаменить(Строка(Новый УникальныйИдентификатор), "-", "x");
			СтрокаПараметра.ИмяЭлементаФормыПараметра = ИмяЭлементаФормы;
			Элемент = Элементы.Добавить(ИмяЭлементаФормы, Тип("ПолеФормы"), ГруппаТекущегоПараметра);
			Элемент.ПутьКДанным = СтрокаПараметра.ИмяРеквизитаФормыПараметра;
			Элемент.Вид = ВидПоляФормы.ПолеВвода;
			Элемент.РастягиватьПоГоризонтали = Истина;
			Элемент.ПоложениеЗаголовка = ПоложениеЗаголовкаЭлементаФормы.Нет;
			Элемент.УстановитьДействие("ПриИзменении", "Подключаемый_ПараметрКритерияОтбораПриИзменении");
			
		КонецЦикла;
	КонецЕсли;
	
	Форма.НаименованиеРеквизитаФормыДинамическийСписок = НаименованиеРеквизитаСписок;
	Если ПараметрыКритерияОтбора <> Неопределено Тогда
		ОбщегоНазначенияКлиентСервер.ДополнитьТаблицу(ТаблицаПараметрыКритериевОтбора, Форма.ПараметрыКритерияОтбора);
	КонецЕсли;
	
	// Заполним синонимы элементов отбора по пути к данным элементов формы
	Для каждого ЭлементФормы из Форма.Элементы Цикл
		Если ТипЗнч(ЭлементФормы) <> Тип("ПолеФормы") Тогда
			Продолжить;
		КонецЕсли;
		Форма.СинонимыЭлементовОтбора.Добавить(ЭлементФормы.ПутьКДанным, ЭлементФормы.Заголовок);
	КонецЦикла;
	
	// Заполним синонимы элементов отбора по реквизитам объекта
	ТипОбъекта = ТипЗнч(ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени(Форма.ИмяФормы));
	МетаданныеОбъекта = Метаданные.НайтиПоТипу(ТипОбъекта);
	ИдентификаторОбъектаМетаданных = ОбщегоНазначения.ИдентификаторОбъектаМетаданных(ТипОбъекта);
	
	Коллекция = Неопределено;
	Если ЗначениеЗаполнено(ИдентификаторОбъектаМетаданных.Родитель)
		И ИдентификаторОбъектаМетаданных.Родитель.Имя = ОбщегоНазначения.ИмяТипаЖурналыДокументов() Тогда
		Коллекция = МетаданныеОбъекта.Графы;
	Иначе
		Коллекция = МетаданныеОбъекта.Реквизиты;
	КонецЕсли;
	
	Для каждого ЭлементКоллекции Из Коллекция Цикл
		Форма.СинонимыЭлементовОтбора.Добавить(ЭлементКоллекции.Имя, ЭлементКоллекции.Синоним);
	КонецЦикла;
	
	// Заполним синонимы элементов отбора по стандартным реквизитам объекта
	Для каждого ЭлементКоллекции Из МетаданныеОбъекта.СтандартныеРеквизиты Цикл
		Форма.СинонимыЭлементовОтбора.Добавить(ЭлементКоллекции.Имя, ЭлементКоллекции.Синоним);
	КонецЦикла;
	
	Форма.ИспользоватьНесколькоОрганизацийЗарплатаКадрыБазовая = ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоОрганизацийЗарплатаКадрыБазовая");
	Форма.ИсключаемыеИменаОтборов = ИсключаемыеИменаОтборов;
	Форма.ЗаполнятьПользовательскийОтборПоОрганизации = ЗаполнятьПользовательскийОтборПоОрганизации;
	
	// По умолчанию добавим в пользовательские настройки отбор по организации
	КоллекцияОтборов = ЗарплатаКадрыКлиентСервер.ФиксированныйОтборДинамическогоСписка(Форма, Список);
	ДобавитьПользовательскийОтборПоОрганизацииВДинамическийСписок(Форма, Список.КомпоновщикНастроек.ПользовательскиеНастройки, КоллекцияОтборов);
	
	// Обновим надпись фиксированных настроек отбора
	ЗарплатаКадрыКлиентСервер.ОбновитьНадписьФиксированногоОтбора(Форма)
	
КонецПроцедуры

// Проверяет настройку пользовательских отборов, если она не удовлетворяет фиксированному отбору динамического списка,
// то неправильные элементы пользовательского отбора удаляются
//
// Параметры:
//		Форма - форма с динамическим списком
//		Настройки - Пользовательские настройки динамического списка
//		ЗагрузкаПользовательскихНастроек - Булево - Истина, если вызов метода производится
//								из обработчика ПередЗагрузкойПользовательскихНастроекНаСервере элемента динамического списка,
//								иначе Ложь
//
Процедура ПроверитьПользовательскиеНастройкиДинамическогоСписка(Форма, ЗагрузкаПользовательскихНастроек = Ложь) Экспорт
	
	Список = Форма[Форма.НаименованиеРеквизитаФормыДинамическийСписок];
	Настройки = Список.КомпоновщикНастроек.ПользовательскиеНастройки;
	
	КоллекцияОтборов = ЗарплатаКадрыКлиентСервер.ФиксированныйОтборДинамическогоСписка(Форма, Список);
	
	Для каждого НастройкаКомпоновщика Из Настройки.Элементы Цикл
		
		Если ТипЗнч(НастройкаКомпоновщика) = Тип("ОтборКомпоновкиДанных") Тогда
			
			ДобавитьПользовательскийОтборПоОрганизацииВДинамическийСписок(Форма, Настройки, КоллекцияОтборов);
			
			УдаляемыеЭлементы = Новый Массив;
			Для каждого ЭлементОтбора Из НастройкаКомпоновщика.Элементы Цикл
				
				Если ЗагрузкаПользовательскихНастроек
					И Форма.ЗаполнятьПользовательскийОтборПоОрганизации
					И ТипЗнч(ЭлементОтбора) <> Тип("ГруппаЭлементовОтбораКомпоновкиДанных")
					И ТипЗнч(ЭлементОтбора.ПравоеЗначение) = Тип("СправочникСсылка.Организации") Тогда
					СтруктураЗначений = Новый Структура("Организация");
					ПолучитьЗначенияПоУмолчанию(СтруктураЗначений);
					ОрганизацияПоУмолчанию = Неопределено;
					СтруктураЗначений.Свойство("Организация", ОрганизацияПоУмолчанию);
					Если ЗначениеЗаполнено(ОрганизацияПоУмолчанию) Тогда
						ЭлементОтбора.ПравоеЗначение = ОрганизацияПоУмолчанию;
					КонецЕсли;
				КонецЕсли;
				
				Если ТипЗнч(ЭлементОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
					ОтборПоиска = ЭлементОтбора.Представление;
				Иначе
					ОтборПоиска = ЭлементОтбора.ЛевоеЗначение;
				КонецЕсли;
				ЭлементФиксированногоОтбора = КоллекцияОтборов.Получить(ОтборПоиска);
				Если ЭлементФиксированногоОтбора <> Неопределено Тогда
					Если ЭлементФиксированногоОтбора.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный Тогда
						УдаляемыеЭлементы.Добавить(ЭлементОтбора);
					ИначеЕсли ТипЗнч(ЭлементОтбора) <> Тип("ГруппаЭлементовОтбораКомпоновкиДанных")
						И ЭлементОтбора.ПравоеЗначение <> ЭлементФиксированногоОтбора.ПравоеЗначение Тогда
						ЭлементОтбора.ПравоеЗначение = ЭлементФиксированногоОтбора.ПравоеЗначение;
					КонецЕсли;
				КонецЕсли;
				
			КонецЦикла;
			
			Для каждого ЭлементОтбора Из УдаляемыеЭлементы Цикл
				НастройкаКомпоновщика.Элементы.Удалить(ЭлементОтбора);
			КонецЦикла;
			
		ИначеЕсли ТипЗнч(НастройкаКомпоновщика) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
			ОтборПоиска = Новый ПолеКомпоновкиДанных(НастройкаКомпоновщика.ИдентификаторПользовательскойНастройки);
			ЭлементФиксированногоОтбора = КоллекцияОтборов.Получить(ОтборПоиска);
			Если ЭлементФиксированногоОтбора <> Неопределено Тогда
				Если ЭлементФиксированногоОтбора.РежимОтображения = РежимОтображенияЭлементаНастройкиКомпоновкиДанных.Недоступный Тогда
					Настройки.Элементы.Удалить(НастройкаКомпоновщика)
				ИначеЕсли НастройкаКомпоновщика.ПравоеЗначение <> ЭлементФиксированногоОтбора.ПравоеЗначение Тогда
					НастройкаКомпоновщика.ПравоеЗначение = ЭлементФиксированногоОтбора.ПравоеЗначение;
				КонецЕсли;
			КонецЕсли;
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ДобавитьПользовательскийОтборПоОрганизацииВДинамическийСписок(Форма, ПользовательскиеНастройки, ФиксированныеОтборы)
	
	Если Не ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоОрганизацийЗарплатаКадрыБазовая") Тогда
		Возврат;
	КонецЕсли;
	
	ИменаИсключаемыхОтборов = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрЗаменить(Форма.ИсключаемыеИменаОтборов, " ",""), ",");
	Для каждого НастройкаКомпоновщика Из ПользовательскиеНастройки.Элементы Цикл
		Если ТипЗнч(НастройкаКомпоновщика) = Тип("ОтборКомпоновкиДанных") Тогда
			Если НастройкаКомпоновщика.ДоступныеПоляОтбора = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			ДоступноеПолеВыбораОрганизация = НастройкаКомпоновщика.ДоступныеПоляОтбора.Элементы.Найти("Организация");
			Если ДоступноеПолеВыбораОрганизация = Неопределено Тогда
				ДоступноеПолеВыбораОрганизация = НастройкаКомпоновщика.ДоступныеПоляОтбора.Элементы.Найти("Владелец");
				Если ДоступноеПолеВыбораОрганизация = Неопределено
					Или ДоступноеПолеВыбораОрганизация.Тип <> Новый ОписаниеТипов("СправочникСсылка.Организации") Тогда
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			Если ИменаИсключаемыхОтборов.Найти(Строка(ДоступноеПолеВыбораОрганизация.Поле)) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;
			НайденОтборПоОрганизации = Ложь;
			Для каждого ЭлементОтбора Из НастройкаКомпоновщика.Элементы Цикл
				Если ТипЗнч(ЭлементОтбора) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
					Продолжить;
				КонецЕсли;
				Если ЭлементОтбора.ЛевоеЗначение = ДоступноеПолеВыбораОрганизация.Поле Тогда
					НайденОтборПоОрганизации = Истина;
					Если ЭлементОтбора.ПравоеЗначение = Неопределено Тогда
						ЭлементОтбора.ПравоеЗначение = Справочники.Организации.ПустаяСсылка();
					КонецЕсли;
					Прервать;
				КонецЕсли;
			КонецЦикла;
			Если Не НайденОтборПоОрганизации Тогда
				Если ФиксированныеОтборы.Получить(ДоступноеПолеВыбораОрганизация.Поле) <> Неопределено Тогда
					НайденОтборПоОрганизации = Истина;
				КонецЕсли;
			КонецЕсли;
			Если Не НайденОтборПоОрганизации Тогда
				ОбщегоНазначенияКлиентСервер.УстановитьЭлементОтбора(
					НастройкаКомпоновщика,
					Строка(ДоступноеПолеВыбораОрганизация.Поле),
					Справочники.Организации.ПустаяСсылка(),
					ВидСравненияКомпоновкиДанных.Равно,
					,
					Ложь,
					РежимОтображенияЭлементаНастройкиКомпоновкиДанных.БыстрыйДоступ,
					Новый УникальныйИдентификатор);
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

///////////////////////////////////////////////////////////////////////////////
// Формирование печатных форм

// Выводит строки по данным заполнения в результирующий табличный документ, в количестве не превышающем
// "ОграничениеСтрок".
// Остальные строки выводятся в дополнительные страницы, которые помещаются в массив "ОбластиДополнительныхСтрок".
//
// Параметры:
//		ТабличныйДокумент - результирующий табличный документ.
//		ДанныеЗаполнения - коллекция с данными для заполнения строк, коллекция доступна для обхода циклом Для Каждого … Из
//		                   … Цикл.
//		ОграничениеСтрок - число, количество строк, размещаемых в основной области.
//		ОбластиДополнительныхСтрок - массив областей с дополнительными строками.
//		ОбластьШапка - область табличного документа для шапки.
//		ОбластьСтрока - область табличного документа для строки.
//		МассивОбластейЗаголовок - массив областей табличного документа для заголовка, выводятся по порядку.
//		МассивОбластейПодвал - массив областей табличного документа для подвала, выводятся по порядку.
//		ВыводитьСтрокиНаВсюСтраницу - Если Истина, то до конца дополнительной страницы будут выведены пустые строки.
//
Процедура СформироватьОбластьТабличногоДокументаСОграниченнымНаборомСтрок(ТабличныйДокумент, ДанныеЗаполнения, ОграничениеСтрок,
	ОбластиДополнительныхСтрок, ОбластьШапка, ОбластьСтрока, МассивОбластейЗаголовок = Неопределено, МассивОбластейПодвал = Неопределено,
	ВыводитьСтрокиНаВсюСтраницу = Ложь) Экспорт
	
	КоличествоВыведенныхСтрок = 0;
	ДополнительнаяСтраница = Новый ТабличныйДокумент;
	
	Для каждого СтрокаДанныхЗаполнения Из ДанныеЗаполнения Цикл
		
		КоличествоВыведенныхСтрок = КоличествоВыведенныхСтрок + 1;
		
		// Если выводимая строка помещается в основной табличный документ.
		Если КоличествоВыведенныхСтрок <= ОграничениеСтрок Тогда
			ОбластьСтрока.Параметры.Заполнить(СтрокаДанныхЗаполнения);
			ТабличныйДокумент.Вывести(ОбластьСтрока);
		КонецЕсли;
		
		// Если выводимая строка не помещается в основной табличный документ, то нужно вывести
		// заголовок и шапку для дополнительной страницы.
		Если КоличествоВыведенныхСтрок = ОграничениеСтрок + 1 Тогда
			
			// Если задан заголовок для дополнительной страницы - выведем его.
			Если МассивОбластейЗаголовок <> Неопределено Тогда
				СтруктураПараметров = Новый Структура("НомерПриложения", ОбластиДополнительныхСтрок.Количество() + 1);
				Для каждого ОбластьЗаголовок Из МассивОбластейЗаголовок Цикл
					ОбластьЗаголовок.Параметры.Заполнить(СтруктураПараметров);
					ДополнительнаяСтраница.Вывести(ОбластьЗаголовок);
				КонецЦикла;
			КонецЕсли;
			
			// Выводим шапку дополнительной страницы.
			ДополнительнаяСтраница.Вывести(ОбластьШапка);
			
			// Повторяем шапку на каждой странице при печати.
			ДополнительнаяСтраница.ПовторятьПриПечатиСтроки = ОбластьШапка;
			
		КонецЕсли;
		
		// Все строки, которые не поместились в основной табличный документ выводим в дополнительную страницу.
		Если КоличествоВыведенныхСтрок > ОграничениеСтрок Тогда
			ОбластьСтрока.Параметры.Заполнить(СтрокаДанныхЗаполнения);
			ДополнительнаяСтраница.Вывести(ОбластьСтрока);
		КонецЕсли;
		
	КонецЦикла;
	
	// Если создавали дополнительную страницу нужно вывести подвал и надпись о продолжении таблицы.
	Если КоличествоВыведенныхСтрок > ОграничениеСтрок Тогда
		
		// Выводим пустые строки до конца дополнительной страницы.
		Если ВыводитьСтрокиНаВсюСтраницу Тогда
			
			Для ПараметрОбласти = 0 По ОбластьСтрока.Параметры.Количество() -1 Цикл
				ОбластьСтрока.Параметры[ПараметрОбласти] = Неопределено;
			КонецЦикла;
			
			ВыводимыеОбласти = Новый Массив();
			ВыводимыеОбласти.Добавить(ОбластьСтрока);
			Если МассивОбластейПодвал <> Неопределено Тогда
				Для каждого ОбластьПодвал Из МассивОбластейПодвал Цикл
					ВыводимыеОбласти.Добавить(ОбластьПодвал);
				КонецЦикла;
			КонецЕсли;
			
			Пока ОбщегоНазначения.ПроверитьВыводТабличногоДокумента(ДополнительнаяСтраница, ВыводимыеОбласти, Ложь) Цикл
				ДополнительнаяСтраница.Вывести(ОбластьСтрока);
			КонецЦикла;
			
		КонецЕсли;
		
		// Если задан подвал для дополнительной страницы - выведем его.
		Если МассивОбластейПодвал <> Неопределено Тогда
			Для каждого ОбластьПодвал Из МассивОбластейПодвал Цикл
				ДополнительнаяСтраница.Вывести(ОбластьПодвал);
			КонецЦикла;
		КонецЕсли;
		
		// Поместим созданную страницу в массив.
		ОбластиДополнительныхСтрок.Добавить(ДополнительнаяСтраница);
		
		// В основном табличном документе напишем, что есть дополнительная страница.
		ОбластьНадписи = ОбластьСтрока.Область(1,1, ОбластьСтрока.ВысотаТаблицы, ОбластьСтрока.ШиринаТаблицы);
		ОбластьНадписи.Объединить();
		ОбластьНадписи.Очистить(Истина, Истина, Истина);
		ТекстНадписи = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'Продолжение таблицы см. в дополнении к документу №%1.'"),
				ОбластиДополнительныхСтрок.Количество());
		ОбластьНадписи.Текст = ТекстНадписи;
		ОбластьНадписи.ГоризонтальноеПоложение = ГоризонтальноеПоложение.Право;
		ОбластьНадписи.АвтовысотаСтроки = Истина;
		ТабличныйДокумент.Вывести(ОбластьСтрока);
		
	// В основном табличном документе выведем пустые строки до заданного количества "ОграничениеСтрок".
	ИначеЕсли КоличествоВыведенныхСтрок < ОграничениеСтрок Тогда
		
		Для ПараметрОбласти = 0 По ОбластьСтрока.Параметры.Количество() -1 Цикл
			ОбластьСтрока.Параметры[ПараметрОбласти] = Неопределено;
		КонецЦикла;
		
		Для Шаг = КоличествоВыведенныхСтрок + 1 По ОграничениеСтрок Цикл
			ТабличныйДокумент.Вывести(ОбластьСтрока);
		КонецЦикла;
		
	КонецЕсли;
	
КонецПроцедуры

// Выводит дополнительные страницы в результирующий табличный документ.
//
// Параметры:
//		ТабличныйДокумент - результирующий табличный документ.
//		ОбластиДополнительныхСтрок - массив областей с дополнительными строками.
//
Процедура ВывестиОбластиТабличногоДокументаСОграниченнымНаборомСтрок(ТабличныйДокумент, ОбластиДополнительныхСтрок) Экспорт
	
	Для каждого ДополнительнаяСтраница Из ОбластиДополнительныхСтрок Цикл
		ТабличныйДокумент.ВывестиГоризонтальныйРазделительСтраниц();
		ТабличныйДокумент.Вывести(ДополнительнаяСтраница);
	КонецЦикла;
	
КонецПроцедуры

// Выводит данные побуквенно
// Параметры:
//			Данные - Строка, которую нужно вывести.
//			Раздел - Макет (область) табличного документа в которую нужно вывести.
//			ИмяПоказателя - Строка, имя ячейки в области к которой прибавляется номер позиции в имени показателя.
//			КоличествоЯчеек - Число, количество ячеек в которые нужно вывести данные.
//			НачальнаяЯчейка - Число, ячейка с которой нужно начать побуквенный вывод.
Процедура ВывестиДанныеПоБуквенно(Данные, Раздел, ИмяПоказателя, КоличествоЯчеек, НачальнаяЯчейка = 1) Экспорт

	Для НомЯчейки = НачальнаяЯчейка По НачальнаяЯчейка + КоличествоЯчеек - 1 Цикл
		Раздел.Области[ИмяПоказателя + Формат(НомЯчейки,"ЧГ=0")].Текст = Сред(Данные, НомЯчейки - НачальнаяЯчейка + 1, 1);
	КонецЦикла;

КонецПроцедуры

// Разбивает строку (не разрывая слов) на подстроки указанной длинны, 
//							строки дополняются пробелами, переводы строк удаляются.
// Параметры:
//  ТекстСтроки  - Строка, которую необходимо разбить на подстроки.
//                 
//  МассивДлинСтрок  - Массив длин строк, если в результирующей строке оказалось подстрок больше.
//                     Чем количество указанных длин, то все "лишние" строки выравниваются по последнему
//                     значению длинны строки.
// Возвращаемое значение:
//   Строка   - разбитая на подстроки указанной длинны.
//
Функция РазбитьСтрокуНаПодСтроки(Знач ТекстСтроки, МассивДлинСтрок) Экспорт

	ВозвращаемаяСтрока = "";
	
	РазделителиСлов = " .,:;?!%\<>+-*/=_" + Символы.ПС;
	
	ТекстСтроки = СокрЛП(ТекстСтроки);
	
	// Обыграем случай, когда у нас многострочная строка.
	Если СтрЧислоСтрок(ТекстСтроки) > 1 Тогда
	
		Для НомерПодстроки = 1 По СтрЧислоСтрок(ТекстСтроки) Цикл
			
			НовыйМассивДлинСтроки = Новый Массив;
			
			Если НомерПодстроки = 1 Тогда
			
				НачальнаяГраница = 0;
			
			Иначе
				
				Если СтрЧислоСтрок(ВозвращаемаяСтрока) > МассивДлинСтрок.ВГраница() Тогда
				
					НачальнаяГраница = МассивДлинСтрок.ВГраница();
					
				Иначе
					
					НачальнаяГраница = СтрЧислоСтрок(ВозвращаемаяСтрока);
				
				КонецЕсли; 
			
			КонецЕсли; 
			
			Для ИндексСтроки = НачальнаяГраница По МассивДлинСтрок.ВГраница() Цикл
			
				НовыйМассивДлинСтроки.Добавить(МассивДлинСтрок[ИндексСтроки]);
			
			КонецЦикла; 
		
			ВозвращаемаяСтрока = ВозвращаемаяСтрока + ?(ПустаяСтрока(ВозвращаемаяСтрока), "", Символы.ПС) + РазбитьСтрокуНаПодСтроки(СтрПолучитьСтроку(ТекстСтроки, НомерПодстроки), НовыйМассивДлинСтроки);
		
		КонецЦикла; 
		
	Иначе
		
		ДлинаСтроки = МассивДлинСтрок[0];
		
		// Если длина строки меньше или равна нужной длине - просто вернем ее.
		Если СтрДлина(ТекстСтроки) <= ДлинаСтроки Тогда
		
			ВозвращаемаяСтрока = ТекстСтроки; 
			
		Иначе
			
			// Заменим все разделители символом _, для удобства анализа.
			ТестируемаяСтрока = ТекстСтроки;
			
			Для НомерРазделителя = 1 По СтрДлина(РазделителиСлов)  Цикл
				
				РазделительСлов = Сред(РазделителиСлов, НомерРазделителя, 1);
				
				ТестируемаяСтрока = СтрЗаменить(ТестируемаяСтрока, РазделительСлов, "_");
			
			КонецЦикла; 
			
			// Найдем первый разделитель
			Разрыв = Найти(ТестируемаяСтрока, "_");
			
			ИндексМассиваДлинСтрок = 0;
			
			// Обрабатываем строку пока она не закончится.
			Пока СтрДлина(ТекстСтроки) > 0 Цикл
				
				Если ИндексМассиваДлинСтрок <= МассивДлинСтрок.ВГраница() Тогда
				
					ДлинаСтроки = МассивДлинСтрок[ИндексМассиваДлинСтрок];
				
				Иначе
				
					ДлинаСтроки = МассивДлинСтрок[МассивДлинСтрок.ВГраница()];
				
				КонецЕсли; 
				
				// Если разрыв больше чем нужная длина
				// если разрывов больше нет
				// и частный случай, когда есть разрыв - пробел в самом конце строки нужной длины
				// или длина оставшейся строки меньше или равна нужной длине.
				Если Разрыв >= ДлинаСтроки ИЛИ Разрыв = 0 ИЛИ Сред(ТекстСтроки, ДлинаСтроки + 1, 1) = " " ИЛИ СтрДлина(ТекстСтроки) <= ДлинаСтроки Тогда
				
					ВозвращаемаяСтрока = ВозвращаемаяСтрока + ?(ПустаяСтрока(ВозвращаемаяСтрока), "", Символы.ПС) + СокрЛП(Лев(ТекстСтроки, ДлинаСтроки));
					
					ТекстСтроки = СокрЛП(Сред(ТекстСтроки, ДлинаСтроки + 1));
					
					ТестируемаяСтрока = Сред(ТестируемаяСтрока, ДлинаСтроки + 1);
					
					Если Лев(ТестируемаяСтрока,1) = "_" Тогда
					
						ТестируемаяСтрока = Сред(ТестируемаяСтрока, 2);
					
					КонецЕсли; 
					
					ИндексМассиваДлинСтрок = ИндексМассиваДлинСтрок + 1;
					
					Разрыв = Найти(ТестируемаяСтрока, "_");
				
				Иначе 
					
					НовыйРазрыв = Найти(Сред(ТестируемаяСтрока, Разрыв + 1), "_");
					
					// Есть еще один разрыв и он вместе с предыдущим меньше или равен длине строки.
					Если НовыйРазрыв > 0 И Разрыв + НовыйРазрыв <= ДлинаСтроки Тогда
						
						Разрыв = Разрыв + НовыйРазрыв;
						
					Иначе
						
						// больше разрывов нет
						// или он вместе с предыдущим больше нужной длины
						ВозвращаемаяСтрока = ВозвращаемаяСтрока + ?(ПустаяСтрока(ВозвращаемаяСтрока), "", Символы.ПС) + СокрЛП(Лев(ТекстСтроки, Разрыв));
						
						ТекстСтроки = СокрЛП(Сред(ТекстСтроки, Разрыв + 1));
						
						ТестируемаяСтрока = Сред(ТестируемаяСтрока, Разрыв + 1);
						
						Если Лев(ТестируемаяСтрока,1) = "_" Тогда
					
							ТестируемаяСтрока = Сред(ТестируемаяСтрока, 2);
					
						КонецЕсли; 
					
						ИндексМассиваДлинСтрок = ИндексМассиваДлинСтрок + 1;
					
						Разрыв = Найти(ТестируемаяСтрока, "_");
						
					КонецЕсли;
				
				КонецЕсли;
				
			КонецЦикла; 
				
		КонецЕсли; 
	
	КонецЕсли;
	
	Если СтрЧислоСтрок(ВозвращаемаяСтрока) > 1 Тогда
		
		ВыровненнаяСтрока = "";
		
		Для НомерПодстроки = 1 По СтрЧислоСтрок(ВозвращаемаяСтрока) - 1 Цикл
			
			ВыравниваемаяСтрока = СтрПолучитьСтроку(ВозвращаемаяСтрока, НомерПодстроки);
			
			Если НомерПодстроки - 1 <= МассивДлинСтрок.ВГраница() Тогда
				
				ДлинаСтроки = МассивДлинСтрок[НомерПодстроки - 1];
				
			Иначе
				
				ДлинаСтроки = МассивДлинСтрок[МассивДлинСтрок.ВГраница()];
				
			КонецЕсли; 
				
			Для НомерПозицииВСтроке = СтрДлина(ВыравниваемаяСтрока) + 1 По ДлинаСтроки Цикл
			
				ВыравниваемаяСтрока = ВыравниваемаяСтрока + " ";
			
			КонецЦикла; 
			
			ВыровненнаяСтрока = ВыровненнаяСтрока + ?(ПустаяСтрока(ВыровненнаяСтрока), "", Символы.ПС) + ВыравниваемаяСтрока;
		
		КонецЦикла;
		
		ВозвращаемаяСтрока = ВыровненнаяСтрока + Символы.ПС + СтрПолучитьСтроку(ВозвращаемаяСтрока, СтрЧислоСтрок(ВозвращаемаяСтрока));
		
	КонецЕсли; 
	
	ВозвращаемаяСтрока = СтрЗаменить(ВозвращаемаяСтрока, Символы.ПС, "");
	
	Возврат ВозвращаемаяСтрока;

КонецФункции // РазбитьСтрокуПоСтрочно()

// Выводит сумму в рублях и копейках в ячейки посимвольно.
// Параметры:
//			Данные - Строка, которую нужно вывести.
//			ТабличныйДокумент - Макет (область) табличного документа в которую нужно вывести.
//			ПрефиксЯчеек - Строка, имя ячейки в области к которой прибавляется номер позиции в имени показателя.
//			КоличествоЯчеек - Число, количество ячеек в которые нужно вывести данные.
Процедура ВывестиСуммуВРубляхКопейкахВЯчейки(Данные, ТабличныйДокумент, ПрефиксЯчеек, КоличествоЯчеек) Экспорт
	ВывестиДанныеПоБуквенно(Прав("                  " + Формат(Данные, "ЧЦ=" + (КоличествоЯчеек + 1) + "; ЧДЦ=0; ЧС=-2; ЧГ="), КоличествоЯчеек), ТабличныйДокумент, ПрефиксЯчеек, КоличествоЯчеек);
КонецПроцедуры

// Возвращает ответственных лиц организации.
//
// Параметры:
//		Организация - ссылка на организацию.
//		Сведения - строка с идентификаторами, разделенными запятыми.
//		ДатаСведений - дата получения сведений.
//
// Возвращаемое значение:
//		СтруктураДанных - структура со свойствами, совпадающими с параметром «Сведения».
//			Допустимые идентификаторы запрашиваемых значений:
//				Руководитель - руководитель организации.
//				ДолжностьРуководителя - должность руководителя.
//				ГлавныйБухгалтер - главбух организации.
//				Кассир - кассир организации.
//				ДолжностьКассира - должность кассира.
//
Функция ОтветственныеЛицаОрганизации(Организация, Сведения, ДатаСведений) Экспорт
	
	Возврат ЗарплатаКадрыВнутренний.ОтветственныеЛицаОрганизации(Организация, Сведения, ДатаСведений)
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ПоддерживаемыеИдентификаторыОтветственныхРаботниковОрганизаций() Экспорт
	
	Возврат ЗарплатаКадрыВнутренний.ПоддерживаемыеИдентификаторыОтветственныхРаботниковОрганизаций();
	
КонецФункции

Процедура ПроверитьВозможностьСменыГоловнойОрганизации(Организация, Отказ) Экспорт
	
	ЗарплатаКадрыВнутренний.ПроверитьВозможностьСменыГоловнойОрганизации(Организация, Отказ);
	
КонецПроцедуры

Функция ОписанияРегистровСодержащихРегистрацииВНалоговомОргане() Экспорт
	
	Возврат ЗарплатаКадрыВнутренний.ОписанияРегистровСодержащихРегистрацииВНалоговомОргане();
	
КонецФункции

Процедура ДобавитьОписаниеРегистровСодержащихРегистрацииВНалоговомОргане(МассивОписаний, ПолноеИмяРегистра, ЕстьПодразделения) Экспорт
	
	МассивОписаний.Добавить(Новый Структура("ПолноеИмяРегистра,ЕстьПодразделения", ПолноеИмяРегистра, ЕстьПодразделения));
	
КонецПроцедуры

Функция УсловияЗапросаПроверкиНеобходимостиЗаполненияПодчиненныхПодразделений(Запрос, ИсточникДанных)
	
	Возврат ЗарплатаКадрыВнутренний.УсловияЗапросаПроверкиНеобходимостиЗаполненияПодчиненныхПодразделений(Запрос, ИсточникДанных);

КонецФункции

Процедура ЗаполнитьСписокТабличныхЧастейИсключаемыхИзКраткогоСостава(МассивТабличныхЧастей) Экспорт
	ЗарплатаКадрыВнутренний.ЗаполнитьСписокТабличныхЧастейИсключаемыхИзКраткогоСостава(МассивТабличныхЧастей);
КонецПроцедуры

Процедура ЗаполнитьПодчиненноеПодразделение(ПодразделениеОбъект, ИсточникДанных)
	
	ЗарплатаКадрыВнутренний.ЗаполнитьПодчиненноеПодразделение(ПодразделениеОбъект, ИсточникДанных);
		
КонецПроцедуры

Процедура ДобавитьПодменю(Форма, ОписаниеМеню, ГруппаПодменю)
	
	Если НЕ ПустаяСтрока(ОписаниеМеню.Заголовок) Тогда
		ГруппаПодменю.Заголовок = ОписаниеМеню.Заголовок;
	КонецЕсли; 
	
	Счетчик = 1;
	ГруппаПодменюДляРазмещенияПунктов = ГруппаПодменю;
	Для каждого ПунктМеню Из ОписаниеМеню.Пункты Цикл
		
		Если ПунктМеню.Вид = ВидГруппыФормы.Подменю Тогда
			
			ГруппаПодменю = Форма.Элементы.Добавить(ГруппаПодменюДляРазмещенияПунктов.Имя +  "Группа" + Счетчик, Тип("ГруппаФормы"), ГруппаПодменюДляРазмещенияПунктов);
			ГруппаПодменю.Вид = ПунктМеню.Вид;
			
			ДобавитьПодменю(Форма, ПунктМеню, ГруппаПодменю);
			
		ИначеЕсли ПунктМеню.Вид = ВидКнопкиФормы.КнопкаКоманднойПанели Тогда
			
			ДобавитьПунктМеню(Форма, ПунктМеню, ГруппаПодменюДляРазмещенияПунктов);
			
		Иначе
			
			ГруппаПодменюДляРазмещенияПунктов = Форма.Элементы.Добавить(ГруппаПодменюДляРазмещенияПунктов.Имя + "Разделитель" + Счетчик, Тип("ГруппаФормы"), ГруппаПодменюДляРазмещенияПунктов);
			ГруппаПодменюДляРазмещенияПунктов.Вид = ВидГруппыФормы.ГруппаКнопок;
			
		КонецЕсли; 
		
		Счетчик = Счетчик + 1;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ДобавитьПунктМеню(Форма, ОписаниеМеню, ГруппаПодменю)
	
	Команда = Форма.Команды.Найти(ОписаниеМеню.ИмяКоманды);
	Если Команда = Неопределено Тогда
		Команда = Форма.Команды.Добавить(ОписаниеМеню.ИмяКоманды);
		Команда.Заголовок = ОписаниеМеню.Заголовок;
		Команда.Действие = ОписаниеМеню.Действие;
	КонецЕсли; 
	
	КнопкаФормы = Форма.Элементы.Добавить(ГруппаПодменю.Имя + ОписаниеМеню.ИмяКоманды, Тип("КнопкаФормы"), ГруппаПодменю);
	КнопкаФормы.Вид = ОписаниеМеню.Вид;
	КнопкаФормы.ИмяКоманды = ОписаниеМеню.ИмяКоманды;
	
КонецПроцедуры

Процедура ЗаполнитьЗначениеРеквизитаОрганизацияПриОднофирменномУчете(Источник, ИмяРеквизитаОрганизация = "Организация") Экспорт

	СтандартнаяОбработка = Истина;
	ЗарплатаКадрыПереопределяемый.ЗаполнитьРеквизитОрганизацияПриОднофирменномУчете(Источник, СтандартнаяОбработка, ИмяРеквизитаОрганизация);
	
	Если СтандартнаяОбработка Тогда 
		
		Если ПолучитьФункциональнуюОпцию("ИспользоватьНесколькоОрганизацийЗарплатаКадрыБазовая") 
			Или Источник.Метаданные().Реквизиты.Найти(ИмяРеквизитаОрганизация) = Неопределено  
			Или ЗначениеЗаполнено(Источник[ИмяРеквизитаОрганизация]) Тогда 
			Возврат;
		КонецЕсли;
	
		Источник[ИмяРеквизитаОрганизация] = Справочники.Организации.ОрганизацияПоУмолчанию();
		
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////////////////////////
// Работа с личными данными физических лиц.

Процедура ОбработатьЗаписьНабораФИО(НаборЗаписей) Экспорт
	ТаблицаФизЛиц = НаборЗаписей.Выгрузить();
	ОбновитьНаименованияФизЛицаИСотрудника(ТаблицаФизЛиц);	
КонецПроцедуры

Процедура ОбновитьНаименованияФизЛицаИСотрудника(ТаблицаФизЛиц) Экспорт
	
 	УстановитьПривилегированныйРежим(Истина);
	
	МенеджерВременныхТаблиц = Новый МенеджерВременныхТаблиц;
	
	Запрос = Новый Запрос;
	Запрос.МенеджерВременныхТаблиц = МенеджерВременныхТаблиц;
	
	Запрос.УстановитьПараметр("ТекущаяДата", '20990101');
	Запрос.УстановитьПараметр("ТекущийНабор", ТаблицаФизЛиц);
	
	Запрос.Текст = 
	"ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ТекущийНабор.ФизическоеЛицо
	|ПОМЕСТИТЬ ВТФизЛицаТекущегоНабора
	|ИЗ
	|	&ТекущийНабор КАК ТекущийНабор
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ФИОФизическихЛицСрезПоследних.ФизическоеЛицо,
	|	ФИОФизическихЛицСрезПоследних.Фамилия,
	|	ФИОФизическихЛицСрезПоследних.Имя,
	|	ФИОФизическихЛицСрезПоследних.Отчество
	|ПОМЕСТИТЬ ВТФИОФизЛицПоследнее
	|ИЗ
	|	ВТФизЛицаТекущегоНабора КАК ФизЛицаТекущегоНабора
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ РегистрСведений.ФИОФизическихЛиц.СрезПоследних(
	|				&ТекущаяДата,
	|				ФизическоеЛицо В
	|					(ВЫБРАТЬ
	|						ФизЛицаТекущегоНабора.ФизическоеЛицо
	|					ИЗ
	|						ВТФизЛицаТекущегоНабора КАК ФизЛицаТекущегоНабора)) КАК ФИОФизическихЛицСрезПоследних
	|		ПО ФизЛицаТекущегоНабора.ФизическоеЛицо = ФИОФизическихЛицСрезПоследних.ФизическоеЛицо
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ФИОФизЛицПоследнее.ФизическоеЛицо,
	|	ФИОФизЛицПоследнее.Фамилия,
	|	ФИОФизЛицПоследнее.Имя,
	|	ФИОФизЛицПоследнее.Отчество,
	|	ФизическиеЛица.Наименование,
	|	ФизическиеЛица.УточнениеНаименования
	|ИЗ
	|	ВТФИОФизЛицПоследнее КАК ФИОФизЛицПоследнее
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ФизическиеЛица КАК ФизическиеЛица
	|		ПО (ФИОФизЛицПоследнее.ФизическоеЛицо = ФизическиеЛица.Ссылка
	|				И (ФизическиеЛица.Наименование <> (ВЫРАЗИТЬ(ФИОФизЛицПоследнее.Фамилия + ВЫБОР
	|							КОГДА ФИОФизЛицПоследнее.Имя = """"
	|								ТОГДА """"
	|							ИНАЧЕ "" "" + ФИОФизЛицПоследнее.Имя
	|						КОНЕЦ + ВЫБОР
	|							КОГДА ФИОФизЛицПоследнее.Отчество = """"
	|								ТОГДА """"
	|							ИНАЧЕ "" "" + ФИОФизЛицПоследнее.Отчество
	|						КОНЕЦ + ВЫБОР
	|							КОГДА ФизическиеЛица.УточнениеНаименования = """"
	|								ТОГДА """"
	|							ИНАЧЕ "" "" + ФизическиеЛица.УточнениеНаименования
	|						КОНЕЦ КАК СТРОКА(50)))
	|					ИЛИ ФизическиеЛица.ФИО <> (ВЫРАЗИТЬ(ФИОФизЛицПоследнее.Фамилия + ВЫБОР
	|							КОГДА ФИОФизЛицПоследнее.Имя = """"
	|								ТОГДА """"
	|							ИНАЧЕ "" "" + ФИОФизЛицПоследнее.Имя
	|						КОНЕЦ + ВЫБОР
	|							КОГДА ФИОФизЛицПоследнее.Отчество = """"
	|								ТОГДА """"
	|							ИНАЧЕ "" "" + ФИОФизЛицПоследнее.Отчество
	|						КОНЕЦ КАК СТРОКА(50)))))
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	Сотрудники.Ссылка КАК Сотрудник,
	|	ФИОФизЛицПоследнее.Фамилия,
	|	ФИОФизЛицПоследнее.Имя,
	|	ФИОФизЛицПоследнее.Отчество,
	|	Сотрудники.УточнениеНаименования,
	|	Сотрудники.Наименование КАК СотрудникНаименование,
	|	ФизическиеЛица.УточнениеНаименования КАК УточнениеНаименованияФизЛица
	|ИЗ
	|	ВТФИОФизЛицПоследнее КАК ФИОФизЛицПоследнее
	|		ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.Сотрудники КАК Сотрудники
	|			ВНУТРЕННЕЕ СОЕДИНЕНИЕ Справочник.ФизическиеЛица КАК ФизическиеЛица
	|			ПО Сотрудники.ФизическоеЛицо = ФизическиеЛица.Ссылка
	|		ПО ФИОФизЛицПоследнее.ФизическоеЛицо = Сотрудники.ФизическоеЛицо
	|			И (Сотрудники.Наименование <> (ВЫРАЗИТЬ(ФИОФизЛицПоследнее.Фамилия + ВЫБОР
	|					КОГДА ФИОФизЛицПоследнее.Имя = """"
	|						ТОГДА """"
	|					ИНАЧЕ "" "" + ФИОФизЛицПоследнее.Имя
	|				КОНЕЦ + ВЫБОР
	|					КОГДА ФИОФизЛицПоследнее.Отчество = """"
	|						ТОГДА """"
	|					ИНАЧЕ "" "" + ФИОФизЛицПоследнее.Отчество
	|				КОНЕЦ + ВЫБОР
	|					КОГДА ФизическиеЛица.УточнениеНаименования = """"
	|						ТОГДА """"
	|					ИНАЧЕ "" "" + ФизическиеЛица.УточнениеНаименования
	|				КОНЕЦ + ВЫБОР
	|					КОГДА Сотрудники.УточнениеНаименования = """"
	|						ТОГДА """"
	|					ИНАЧЕ "" "" + Сотрудники.УточнениеНаименования
	|				КОНЕЦ КАК СТРОКА(50))))";
				   
	Результат = Запрос.ВыполнитьПакет();
	
	ИзменитьНаименованиеФизическихЛиц(Результат[2].Выбрать());
	ИзменитьНаименованиеСотрудников(Результат[3].Выбрать());
	
	Если ОбщегоНазначенияКлиентСервер.ПодсистемаСуществует("ЗарплатаКадрыКорпоративнаяПодсистемы.ПодборПерсонала") Тогда
		Модуль = ОбщегоНазначенияКлиентСервер.ОбщийМодуль("ПодборПерсонала");
		Модуль.ИзменитьНаименованиеКандидатов(МенеджерВременныхТаблиц);
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Ложь);
	
КонецПроцедуры

Процедура ИзменитьНаименованиеФизическихЛиц(ДанныеФИО)
	
	Пока ДанныеФИО.Следующий() Цикл
		
		ФизЛицоОбъект = ДанныеФИО.ФизическоеЛицо.ПолучитьОбъект();
		
		СтруктураФИО = ФизическиеЛицаКлиентСервер.ФамилияИмяОтчество(ДанныеФИО.Наименование);
		НаименованиеФизЛица = СтруктураФИО.Фамилия + " " + СтруктураФИО.Имя + " " + СтруктураФИО.Отчество;
		
		Если СокрЛП(НаименованиеФизЛица) = КадровыйУчетКлиентСервер.ПолноеНаименованиеСотрудника(ДанныеФИО.Фамилия, ДанныеФИО.Имя, ДанныеФИО.Отчество, ДанныеФИО.УточнениеНаименования) Тогда
			Продолжить;
		КонецЕсли;
		
		Попытка 
			ФизЛицоОбъект.Заблокировать();
		Исключение
			Отказ = Истина;
			ТекстИсключенияЗаписи = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не удалось изменить имя физического лица %1.
			|Возможно, данные сотрудника редактируются другим пользователем'"),
			ФизЛицоОбъект.Наименование);
			ВызватьИсключение ТекстИсключенияЗаписи;
			
		КонецПопытки;
		
		ФизЛицоОбъект.Наименование = КадровыйУчетКлиентСервер.ПолноеНаименованиеСотрудника(
				ДанныеФИО.Фамилия,
				ДанныеФИО.Имя,
				ДанныеФИО.Отчество,
				ДанныеФИО.УточнениеНаименования);
		
		ФизЛицоОбъект.Записать();
		
	КонецЦикла;
	
КонецПроцедуры

Процедура ИзменитьНаименованиеСотрудников(ДанныеФИО)
	
	Пока ДанныеФИО.Следующий() Цикл
		
		СтруктураФИО = ФизическиеЛицаКлиентСервер.ФамилияИмяОтчество(ДанныеФИО.СотрудникНаименование);
		НаименованиеСотрудника = СтруктураФИО.Фамилия + " " + СтруктураФИО.Имя + " " + СтруктураФИО.Отчество;
		
		ПолноеНаименованиеСотрудника  = КадровыйУчетКлиентСервер.ПолноеНаименованиеСотрудника(
				ДанныеФИО.Фамилия,
				ДанныеФИО.Имя,
				ДанныеФИО.Отчество,
				ДанныеФИО.УточнениеНаименованияФизЛица,
				ДанныеФИО.УточнениеНаименования);
		
		Если СокрЛП(НаименованиеСотрудника) = ПолноеНаименованиеСотрудника Тогда
			Продолжить;
		КонецЕсли;
		
		СотрудникОбъект = ДанныеФИО.Сотрудник.ПолучитьОбъект();
		
		Попытка 
			СотрудникОбъект.Заблокировать();
		Исключение
			Отказ = Истина;
			ТекстИсключенияЗаписи = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'Не удалось изменить имя сотрудника %1.
			|Возможно, данные сотрудника редактируются другим пользователем'"),
			СотрудникОбъект.Наименование);
			ВызватьИсключение ТекстИсключенияЗаписи;
			
		КонецПопытки;
		
		СотрудникОбъект.Наименование = ПолноеНаименованиеСотрудника;
		
		СотрудникОбъект.Записать();
	КонецЦикла;
	
КонецПроцедуры

#Область РаботаСПотокамиXML

// Создает и возвращает объект ЗаписьXML, для создания XML документа.
Функция СоздатьПотокXML(ИмяФайла = Неопределено, Кодировка  = "windows-1251") Экспорт	
	ПотокXML = Новый ЗаписьXML();
	
	ПотокXML.УстановитьСтроку(Кодировка);
	ПотокXML.Отступ = Истина;
	Если ИмяФайла <> Неопределено Тогда
		ПотокXML.ОткрытьФайл(ИмяФайла, Кодировка);
	КонецЕсли;
	
	ПотокXML.ЗаписатьОбъявлениеXML();
	
	Возврат ПотокXML;
	
КонецФункции

// Сохраняет документ XML  на диск и закрывает запись XML.
Функция ЗаписатьПотокXML(ПотокXML) Экспорт
	Возврат ПотокXML.Закрыть();	
КонецФункции

/////////////////////////////////////
// Работа с деревом XML

// КОМПОЗИЦИЯ ДЕРЕВА

// Создает объект дерево значений, представляющее XML файл.
Функция СоздатьДеревоXML() Экспорт	
	НовоеДеревоXML = Новый ДеревоЗначений;
	НовоеДеревоXML.Колонки.Добавить("Имя",      Новый ОписаниеТипов("Строка"));
	НовоеДеревоXML.Колонки.Добавить("Значение", Новый ОписаниеТипов("Строка"));
	
	Возврат НовоеДеревоXML;
	
КонецФункции

Функция ДобавитьУзелВДеревоXML(Ветка, Имя, Значение, СписокАтрибутов = Неопределено, ТипДанных = "", ЗначениеЗаписи = Неопределено) Экспорт
	ПустаяДата = Дата(1,1,1);
	
	НовыйУзел = Ветка.Строки.Добавить();
	НовыйУзел.Имя = Имя;
	НовыйУзел.Значение = Значение;
	
	Если СписокАтрибутов <> Неопределено Тогда
		ВеткаАтрибутов = НовыйУзел.Строки.Добавить();
		ВеткаАтрибутов.Имя = "АтрибутыXMLУзла";
		ВеткаАтрибутов.Значение = Неопределено;
		
		Для Каждого ЭлементСпискаАтрибутов Из СписокАтрибутов Цикл
			ЛистАтрибутов = ВеткаАтрибутов.Строки.Добавить();
			ЛистАтрибутов.Имя = ЭлементСпискаАтрибутов.Ключ;
			// Доделать до правильного преобразования.
			ЛистАтрибутов.Значение = Строка(ЭлементСпискаАтрибутов.Значение);
		КонецЦикла;
		
	КонецЕсли;
	
	Если ТипДанных = "СТРОКА" И ЗначениеЗаписи <> Неопределено Тогда
		ЗначениеЗаписи = "";
	ИначеЕсли ТипДанных = "ЧИСЛО" И ЗначениеЗаписи <> Неопределено Тогда
		Если ТипЗнч(ЗначениеЗаписи) = Тип("Число") Тогда
			ЗначениеЗаписи = 0;	
		Иначе
			ЗначениеЗаписи = "";
		КонецЕсли;	
	ИначеЕсли ТипДанных = "ДАТА" И ЗначениеЗаписи <> Неопределено Тогда
		ЗначениеЗаписи = ПустаяДата;	
	КонецЕсли;	
	
	Возврат НовыйУзел;
	
КонецФункции

// Записывает значения из дерева значение в поток связанный с файлом XML.
Процедура ЗаписатьУзелДереваXMLВXML(СтрокаДерева, ПотокXML, ПрефиксПространстваИмен = Неопределено, URIПространстваИмен = Неопределено) Экспорт	
	Если ТипЗнч(СтрокаДерева) = Тип("СтрокаДереваЗначений") Тогда
		
		Если НЕ ПустаяСтрока(СтрокаДерева.Имя) Тогда
			
			ПотокXML.ЗаписатьНачалоЭлемента(СтрЗаменить(СтрокаДерева.Имя,"__","-"));
			Если ПрефиксПространстваИмен <> Неопределено И URIПространстваИмен <> Неопределено Тогда
				ПотокXML.ЗаписатьСоответствиеПространстваИмен(ПрефиксПространстваИмен, URIПространстваИмен);
			КонецЕсли;
			СписокАтрибутов = СтрокаДерева.Строки.Найти("АтрибутыXMLУзла", "Имя", Ложь);
			
			Если СписокАтрибутов <> Неопределено Тогда
				Для каждого СтрокаСАтрибутом Из СписокАтрибутов.Строки Цикл
					ПотокXML.ЗаписатьАтрибут(СтрокаСАтрибутом.Имя, СтрокаСАтрибутом.Значение);
				КонецЦикла;
			КонецЕсли;
			
			ПотокXML.ЗаписатьТекст(?(СтрокаДерева.Значение = "00.00.0000", "", СтрокаДерева.Значение));
			
		КонецЕсли;
		
	КонецЕсли;
	
	Для каждого Лист Из СтрокаДерева.Строки Цикл
		Если Лист.Имя = "АтрибутыXMLУзла" Тогда
			Продолжить;
		КонецЕсли;
		ЗаписатьУзелДереваXMLВXML(Лист, ПотокXML, ПрефиксПространстваИмен, URIПространстваИмен);
	КонецЦикла;
	
	Если ТипЗнч(СтрокаДерева) = Тип("СтрокаДереваЗначений") Тогда
		Если НЕ ПустаяСтрока(СтрокаДерева.Имя) Тогда
			ПотокXML.ЗаписатьКонецЭлемента();
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

// ИМПОРТ / ЭКСПОРТ ДЕРЕВА

Функция ЗагрузитьXMLВДокументDOM(ТекстXML) Экспорт
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(ТекстXML);
	
	ПостроительDOM = Новый ПостроительDOM;
	
	ДокументDOM = ПостроительDOM.Прочитать(ЧтениеXML);
	
	Возврат ДокументDOM;
КонецФункции	

Функция ЗагрузитьФорматНабораЗаписей(Знач ДеревоФормата, Знач ИмяНабораЗаписей, НомерВыбираемогоЭлемента = 1) Экспорт	
	ФорматНабора = Новый Структура();
	
	//СтрокаНабораЗаписей = ДеревоФормата.Строки.Найти(ИмяНабораЗаписей, "ИмяЗаписи");
	УзлыФормата = ДеревоФормата.ДочерниеУзлы[0].ПолучитьЭлементыПоИмени(ИмяНабораЗаписей)[0].ДочерниеУзлы;
	
	Для Каждого УзелФормата Из УзлыФормата Цикл
		
		ФорматЗаписи = Новый Структура("ТипДанных, Размер, РазрядностьДробнойЧасти, Поля, Значение, ЭлементНеОбязателен, ТипЭлемента, НеВыводитьВФайл");
		
		// Имя записи хранится в 4 колонке.
		ИмяЗаписи =  УзелФормата.ДочерниеУзлы[3].ТекстовоеСодержимое;
		
		// Тип данных хранится во 2 колонке.
		ТипДанных = ВРег(УзелФормата.ДочерниеУзлы[1].ТекстовоеСодержимое);
		
		// Признак обязательности элемента хранится в 5-й колонке.
		ЭлементНеОбязателен = (ВРег(УзелФормата.ДочерниеУзлы[4].ТекстовоеСодержимое) = "НЕ ОБЯЗАТЕЛЬНО" Или ВРег(УзелФормата.ДочерниеУзлы[4].ТекстовоеСодержимое) = "Н");
		
		Если УзелФормата.ДочерниеУзлы.Количество() = 7 И УзелФормата.ДочерниеУзлы[6].ИмяУзла = "ТипЭлемента" Тогда
			ТипЭлемента = ВРег(УзелФормата.ДочерниеУзлы[6].ТекстовоеСодержимое);
		Иначе
			ТипЭлемента = "С";
		КонецЕсли;	
		
		Если ТипДанных = "" Тогда// Если тип данных не задан, то встретили строку - группировку.
			Продолжить;
		КонецЕсли; 
		
		ПозицияРазделителя = Найти(ТипДанных,"/");
		Если ПозицияРазделителя <> 0 Тогда
			ТипДанных = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ТипДанных, "/")[НомерВыбираемогоЭлемента-1];
		КонецЕсли;
		
		ПозицияРазделителя = Найти(ИмяЗаписи,"/");
		Если ПозицияРазделителя <> 0 Тогда
			ИмяЗаписи = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЗаписи, "/")[НомерВыбираемогоЭлемента-1];
		КонецЕсли;
		
		ФорматЗаписи.ТипДанных =  ТипДанных;
		ФорматЗаписи.ЭлементНеОбязателен = ЭлементНеОбязателен;
		ФорматЗаписи.ТипЭлемента = ТипЭлемента;
		ФорматЗаписи.НеВыводитьВФайл = Ложь;
		// Размер хранится в 3 колонке.
		СтрРазмерПоля =  УзелФормата.ДочерниеУзлы[2].ТекстовоеСодержимое;
		
		Если ФорматЗаписи.ТипДанных = "КОНСТАНТА" Тогда
			
			// В колонке "размер" должно указываться значение константы.
			ФорматЗаписи.Значение = СтрРазмерПоля;
			
		ИначеЕсли ФорматЗаписи.ТипДанных = "ЧИСЛО" Тогда
			
			ПозицияТочки = Найти(СтрРазмерПоля,".");
			Если ПозицияТочки<>0 Тогда
				ФорматЗаписи.Размер = Число(Лев(СтрРазмерПоля,ПозицияТочки-1));
				ФорматЗаписи.РазрядностьДробнойЧасти = Число(Сред(СтрРазмерПоля,ПозицияТочки+1));
			Иначе	
				ФорматЗаписи.Размер = Число(СтрРазмерПоля);
				ФорматЗаписи.РазрядностьДробнойЧасти = 0;
			КонецЕсли;	 
			
			ФорматЗаписи.Значение = 0;
			
		ИначеЕсли ФорматЗаписи.ТипДанных = "СТРОКА" Тогда
			
			ФорматЗаписи.Размер = Число(СтрРазмерПоля);
			
			ФорматЗаписи.Значение = "";
			
		ИначеЕсли ФорматЗаписи.ТипДанных = "ДАТА" Тогда
			
			ФорматЗаписи.Значение = Дата('00010101');
			
		ИначеЕсли ФорматЗаписи.ТипДанных = "ТАБЛИЦА" Тогда	
			
			// Имя области-описания формата полей таблицы или структуры хранится в колонке размер.
			ФорматЗаписи.Поля = ПолучитьФорматЗаписиИзДереваФормата(ДеревоФормата, СтрРазмерПоля);
			ФорматЗаписи.Значение = Новый ТаблицаЗначений;
			
			Для каждого Поле Из ФорматЗаписи.Поля Цикл
				
				Если Поле.ТипДанных = "ТАБЛИЦА" Тогда
					ФорматЗаписи.Значение.Колонки.Добавить(Поле.ИмяПоля);
				Иначе	
					Если Поле.ТипДанных = "ЧИСЛО" Тогда
						ОписаниеТиповПоля = Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(Поле.Размер, Поле.РазрядностьДробнойЧасти));
					ИначеЕсли Поле.ТипДанных = "СТРОКА" Тогда
						ОписаниеТиповПоля = Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(Поле.Размер));
					ИначеЕсли Поле.ТипДанных = "ДАТА" Тогда
						ОписаниеТиповПоля = Новый ОписаниеТипов("Дата", , , Новый КвалификаторыДаты(ЧастиДаты.Дата));
					КонецЕсли; 
					ФорматЗаписи.Значение.Колонки.Добавить(Поле.ИмяПоля, ОписаниеТиповПоля);
				КонецЕсли;	
				
			КонецЦикла; 
				
		ИначеЕсли ФорматЗаписи.ТипДанных = "СТРУКТУРА" Тогда	
			
			ПозицияРазделителя = Найти(ИмяЗаписи,"/");
			Если ПозицияРазделителя <> 0 Тогда
				ИмяЗаписи = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЗаписи, "/")[НомерВыбираемогоЭлемента-1]
			КонецЕсли;
			ПозицияРазделителя = Найти(СтрРазмерПоля,"/");
			Если ПозицияРазделителя <> 0 Тогда
				СтрРазмерПоля = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(СтрРазмерПоля, "/")[НомерВыбираемогоЭлемента-1]
			КонецЕсли;
			
			// Имя области-описания формата полей таблицы или структуры хранится в колонке размер.
			ФорматЗаписи.Поля = ПолучитьФорматЗаписиИзДереваФормата(ДеревоФормата, СтрРазмерПоля);
			ФорматЗаписи.Значение = Новый Структура;
			Для каждого Поле Из ФорматЗаписи.Поля Цикл
				
				ПустоеЗначениеПоля = Неопределено;
				Если Поле.ТипДанных = "ЧИСЛО" Тогда
					ПустоеЗначениеПоля = 0;
				ИначеЕсли Поле.ТипДанных = "ДАТА" Тогда
					ПустоеЗначениеПоля = Дата('00010101');
				Иначе
					ПустоеЗначениеПоля = "";
				КонецЕсли; 
				
				ФорматЗаписи.Значение.Вставить(Поле.ИмяПоля, ПустоеЗначениеПоля);
				
			КонецЦикла; 
			
		ИначеЕсли ФорматЗаписи.ТипДанных = "НАБОРЗАПИСЕЙ" Тогда
			
			// Имя набора записей хранится в третьей колонке.
			ИмяНабора = УзелФормата.ДочерниеУзлы[2].ТекстовоеСодержимое;
			ПозицияРазделителя = Найти(ИмяНабора,"/");
			Если ПозицияРазделителя <> 0 Тогда
				ИмяНабора = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяНабора, "/")[НомерВыбираемогоЭлемента-1]
			КонецЕсли;
			ПозицияРазделителя = Найти(ИмяЗаписи,"/");
			Если ПозицияРазделителя <> 0 Тогда
				ИмяЗаписи = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяЗаписи, "/")[НомерВыбираемогоЭлемента-1]
			КонецЕсли;
			ФорматЗаписи.Значение = ЗагрузитьФорматНабораЗаписей(ДеревоФормата, ИмяНабора, НомерВыбираемогоЭлемента);
			
		КонецЕсли;	
		
		ФорматНабора.Вставить(ИмяЗаписи, ФорматЗаписи);
		
	КонецЦикла;	
	
	Возврат ФорматНабора;
		
КонецФункции

// Добавляет реквизит в дерево значений, представляющее XML файл.
Процедура ДобавитьИнформациюВДерево(ДеревоВыгрузки, НаборЗаписей) Экспорт	
		
	ПустаяДата = Дата(1,1,1);
	
	Для каждого ЭлементНабора Из НаборЗаписей Цикл
		ИмяЗаписи = ЭлементНабора.Ключ;
				
		Запись = ЭлементНабора.Значение;
		
		Если Запись.НеВыводитьВФайл Тогда 
			Запись.НеВыводитьВФайл = Ложь;
			Продолжить;
		КонецЕсли;	
	
		ТипДанных = Запись.ТипДанных;
		Если ТипДанных = "КОНСТАНТА" Тогда
			
			ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, Запись.Значение, , ТипДанных, Запись.Значение);
			
		ИначеЕсли ТипДанных = "ЧИСЛО" Тогда
			
			// для проверок
			// Запись.Размер 
			// Запись.РазрядностьДробнойЧасти
			ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, Формат(Запись.Значение,"ЧЦ=" + Запись.Размер + "; ЧДЦ=" + Запись.РазрядностьДробнойЧасти + "; ЧРД=.; ЧН=; ЧГ=0"), , ТипДанных, Запись.Значение);
			Запись.НеВыводитьВФайл = Ложь;
		ИначеЕсли ТипДанных = "СТРОКА" Тогда
			
			// для проверок
			// Запись.Размер 
			
			ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, Запись.Значение, ,ТипДанных, Запись.Значение);
			
		ИначеЕсли ТипДанных = "ДАТА" Тогда
			
			ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, ?(Запись.Значение = ПустаяДата,"00.00.0000", Формат(Запись.Значение,"ДЛФ=D")), ,ТипДанных, Запись.Значение);
			
		ИначеЕсли ТипДанных = "ТАБЛИЦА" Тогда	
			
			ПроверятьНеобязательныеПоля = Ложь;
			Для каждого Поле Из Запись.Поля Цикл
				ПроверятьНеобязательныеПоля = Поле.ЭлементНеОбязателен;
				Если ПроверятьНеобязательныеПоля Тогда
					Прервать;
				КонецЕсли;
			КонецЦикла; 
			
			Для каждого СтрокаТЗ Из Запись.Значение Цикл
				
				ВыводитьНеобязательныеПоля = Ложь;
				Если ПроверятьНеобязательныеПоля Тогда
					Для каждого Поле Из Запись.Поля Цикл
						Если Поле.ЭлементНеОбязателен Тогда
							ВыводитьНеобязательныеПоля = ЗначениеЗаполнено(СтрокаТЗ[Поле.ИмяПоля]);
							Если ВыводитьНеобязательныеПоля Тогда
								Прервать;
							КонецЕсли;
						КонецЕсли;
					КонецЦикла; 
				КонецЕсли;
				
				Атрибуты = Новый Структура;
				Для каждого Поле Из Запись.Поля Цикл
					
					Если Поле.ЭлементНеОбязателен И Не ВыводитьНеобязательныеПоля Тогда
						Продолжить;
					КонецЕсли;
					
					Данные = СтрокаТЗ[Поле.ИмяПоля];
					
					Если Поле.ТипДанных = "ЧИСЛО" Тогда
						Данные = Формат(Данные,"ЧЦ=" + Поле.Размер + "; ЧДЦ=" + Поле.РазрядностьДробнойЧасти + "; ЧРД=.; ЧН=; ЧГ=0")
					ИначеЕсли Поле.ТипДанных = "ДАТА" Тогда
						Если Не ЗначениеЗаполнено(Данные) Тогда
							Данные = ""
						Иначе
							Данные = Формат(Данные,"ДЛФ=D");
						КонецЕсли;
					КонецЕсли;
					
					Если Поле.ТипЭлемента = "А" И НЕ Поле.НеВыводитьВФайл Тогда
						Атрибуты.Вставить(Поле.ИмяПоля, Данные);
					КонецЕсли;
					
				КонецЦикла;
				
				ВеткаСтрокиТЗ = ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, "", Атрибуты);
				
				Для каждого Поле Из Запись.Поля Цикл
					
					Если Поле.ТипЭлемента = "А" Тогда
						Поле.НеВыводитьВФайл = Ложь;
						Продолжить;
					КонецЕсли;
					
					Если Поле.НеВыводитьВФайл Тогда
						Поле.НеВыводитьВФайл = Ложь;
						Продолжить;
					КонецЕсли;	
					
					Если Поле.ЭлементНеОбязателен И Не ВыводитьНеобязательныеПоля Тогда
						Продолжить;
					КонецЕсли;
					
					ДобавитьИнформациюВДерево(ВеткаСтрокиТЗ, СтрокаТЗ[Поле.ИмяПоля])
					
				КонецЦикла;
				
			КонецЦикла; 
			
		ИначеЕсли ТипДанных = "СТРУКТУРА" Тогда	
			МассивДанных = Новый Массив;
			Атрибуты = Новый Структура;
			Для каждого Поле Из Запись.Поля Цикл
				
				Данные = Запись.Значение[Поле.ИмяПоля];
				
				Если Поле.ЭлементНеОбязателен И Не ЗначениеЗаполнено(Данные) Тогда
					Продолжить;
				КонецЕсли;
				
				ПустоеЗначение = "";
				Если Поле.ТипДанных = "ЧИСЛО" Тогда
					Если ТипЗнч(Данные) = Тип("Число") Тогда
						ПустоеЗначение = 0;	
					КонецЕсли;	
					Данные = Формат(Данные,"ЧЦ=" + Поле.Размер + "; ЧДЦ=" + Поле.РазрядностьДробнойЧасти + "; ЧРД=.; ЧН=; ЧГ=0");
				ИначеЕсли Поле.ТипДанных = "ДАТА" Тогда
					Если Не ЗначениеЗаполнено(Данные) Тогда
						Данные = ""
					Иначе
						Данные = Формат(Данные,"ДЛФ=D");
						ПустоеЗначение = '00010101';
					КонецЕсли;
				КонецЕсли;
				
				Если Поле.ТипЭлемента = "А" И НЕ Поле.НеВыводитьВФайл  Тогда
					Атрибуты.Вставить(Поле.ИмяПоля, Данные);
				ИначеЕсли НЕ Поле.НеВыводитьВФайл Тогда 
					СтруктураДанных = Новый Структура("ИмяПоля, Значение, Данные, ТипДанных", Поле.ИмяПоля, Запись.Значение[Поле.ИмяПоля], Данные, Поле.ТипДанных);
					МассивДанных.Добавить(СтруктураДанных);
				КонецЕсли;
				Поле.НеВыводитьВФайл = Ложь;
				Запись.Значение[Поле.ИмяПоля] = ПустоеЗначение;	
			КонецЦикла; 
				
			ВеткаСтруктуры = ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, "", Атрибуты);
			
			Для Каждого Поле Из МассивДанных Цикл
				ДобавитьУзелВДеревоXML(ВеткаСтруктуры, Поле.ИмяПоля, Поле.Данные, ,Поле.ТипДанных, Поле.Данные);
            КонецЦикла;

		ИначеЕсли ТипДанных = "НАБОРЗАПИСЕЙ" Тогда
			
			Значение = Запись.Значение;
			
			Атрибуты = Новый Структура;
			Для каждого Поле Из Значение Цикл
				Если Поле.Значение.ТипЭлемента = "А" И НЕ Поле.Значение.НеВыводитьВФайл  Тогда
					Данные = Поле.Значение.Значение;
					Если Поле.Значение.ТипДанных = "ЧИСЛО" Тогда
						Данные = Формат(Данные,"ЧЦ=" + Поле.Значение.Размер + "; ЧДЦ=" + Поле.Значение.РазрядностьДробнойЧасти + "; ЧРД=.; ЧН=; ЧГ=0")
					ИначеЕсли Поле.Значение.ТипДанных = "ДАТА" Тогда
						Если Не ЗначениеЗаполнено(Данные) Тогда
							Данные = ""
						Иначе
							Данные = Формат(Данные,"ДЛФ=D");
						КонецЕсли;
					КонецЕсли;
					Атрибуты.Вставить(Поле.Ключ, Данные);
					Значение.Удалить(Поле.Ключ);
				КонецЕсли;
			КонецЦикла;
			
			ДобавитьИнформациюВДерево(ДобавитьУзелВДеревоXML(ДеревоВыгрузки, ИмяЗаписи, "", Атрибуты), Значение);
			
		КонецЕсли;	
		
	КонецЦикла; 
	
КонецПроцедуры

#КонецОбласти

////////////////////////////////////////////////////////////////////////////////
// Прочие процедуры и функции

Функция КоличествоНеОпределенныхЗначений(ЗаполняемыеЗначения)
	
	Количество = 0;
	
	Для Каждого КлючЗначение Из ЗаполняемыеЗначения Цикл
		Если НЕ ЗначениеЗаполнено(КлючЗначение.Значение) Тогда
			Количество = Количество + 1;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Количество;
	
КонецФункции

Процедура ПрочитатьПериодическиеСведенияОрганизации(Форма)
	
	РедактированиеПериодическихСведений.ПрочитатьЗаписьДляРедактированияВФорме(Форма, "ИсторияРегистрацийВОрганеПФР", Форма.ОрганизацияСсылка);
	Форма.ИсторияРегистрацийВОрганеПФРПериодСтрокой = ЗарплатаКадрыКлиентСервер.ПолучитьПредставлениеКвартала(Форма.ИсторияРегистрацийВОрганеПФР.Период);
	
	РедактированиеПериодическихСведений.ПрочитатьЗаписьДляРедактированияВФорме(Форма, "ТерриториальныеУсловияПФР", Форма.ОрганизацияСсылка);
	
КонецПроцедуры

Процедура ЗаписатьПериодическиеСведенияОрганизации(Форма)
	
	РедактированиеПериодическихСведений.ЗаписатьЗаписьПослеРедактированияВФорме(Форма, "ИсторияРегистрацийВОрганеПФР", Форма.ОрганизацияСсылка);
	РедактированиеПериодическихСведений.ЗаписатьЗаписьПослеРедактированияВФорме(Форма, "ТерриториальныеУсловияПФР", Форма.ОрганизацияСсылка);
	
КонецПроцедуры

// Процедура вызывается при заполнении формы "Согласие на обработку персональных данных"
//  данными, переданных в качестве параметров, субъектов.
//
// Параметры:
//		СубъектыПерсональныхДанных 	- данные формы коллекция, содержащая сведения о субъектах.
//		ДатаАктуальности			- дата, на которую нужно заполнить сведения.
//
Процедура ДополнитьДанныеСубъектовПерсональныхДанных(СубъектыПерсональныхДанных, ДатаАктуальности) Экспорт 
	
	СписокФизическихЛиц = ОбщегоНазначения.ВыгрузитьКолонку(СубъектыПерсональныхДанных, "Субъект", Истина);	
	КадровыеДанные = "ФИОПолные, ДокументСерия, ДокументНомер, АдресПоПропискеПредставление";
	
	КадровыеДанныеФизическихЛиц = КадровыйУчет.КадровыеДанныеФизическихЛиц(Истина, СписокФизическихЛиц, КадровыеДанные, ДатаАктуальности);
	
	Для Каждого ТекСтрока Из СубъектыПерсональныхДанных Цикл 
		КадровыеДанныеФизическогоЛица = КадровыеДанныеФизическихЛиц.Найти(ТекСтрока.Субъект, "ФизическоеЛицо");
		Если КадровыеДанныеФизическогоЛица <> Неопределено Тогда
			ТекСтрока.ФИО = КадровыеДанныеФизическогоЛица.ФИОПолные;
			ТекСтрока.Адрес = КадровыеДанныеФизическогоЛица.АдресПоПропискеПредставление;
			ТекСтрока.ПаспортныеДанные = Строка(КадровыеДанныеФизическогоЛица.ДокументСерия) + " " + Строка(КадровыеДанныеФизическогоЛица.ДокументНомер);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Процедура вызывается при заполнении формы "Согласие на обработку персональных данных"
//  данными организации.
//
// Параметры:
//		Организация					- организация - оператор персональных данных.
//		ДанныеОрганизации			- структура с данными об организации (адрес, ФИО ответственного и т.д.).
//		ДатаАктуальности			- дата, на которую нужно заполнить сведения.
//
Процедура ДополнитьДанныеОрганизацииОператораПерсональныхДанных(Организация, ДанныеОрганизации, ДатаАктуальности) Экспорт 

	АдресаОрганизаций = УправлениеКонтактнойИнформациейЗарплатаКадры.АдресаОрганизаций(Организация);
	ДанныеОрганизации.АдресОрганизации = УправлениеКонтактнойИнформациейЗарплатаКадры.АдресОрганизации(АдресаОрганизаций, Организация, Справочники.ВидыКонтактнойИнформации.ЮрАдресОрганизации).Представление;
	
КонецПроцедуры

Функция ПолучитьФорматЗаписиИзДереваФормата(Знач ДеревоФормата, Знач ИмяЗаписи)
	
	ТаблицаФормаЗаписи = Новый ТаблицаЗначений;
	ТаблицаФормаЗаписи.Колонки.Добавить("ИмяПоля",					Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(100)));
	ТаблицаФормаЗаписи.Колонки.Добавить("ТипДанных",				Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(10)));
	ТаблицаФормаЗаписи.Колонки.Добавить("ТипЭлемента",				Новый ОписаниеТипов("Строка", , Новый КвалификаторыСтроки(10)));
	ТаблицаФормаЗаписи.Колонки.Добавить("Размер",					Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(5)));
	ТаблицаФормаЗаписи.Колонки.Добавить("РазрядностьДробнойЧасти",	Новый ОписаниеТипов("Число", Новый КвалификаторыЧисла(5)));
	ТаблицаФормаЗаписи.Колонки.Добавить("ЭлементНеОбязателен", Новый ОписаниеТипов("Булево"));
	ТаблицаФормаЗаписи.Колонки.Добавить("НеВыводитьВФайл", Новый ОписаниеТипов("Булево"));
	
	УзлыФормата = ДеревоФормата.ДочерниеУзлы[0].ПолучитьЭлементыПоИмени(ИмяЗаписи)[0].ДочерниеУзлы;
	
	Для Каждого УзелФормата Из УзлыФормата Цикл
		
		// Имя поля хранится в 4-ой колонке.
		ИмяПоля = УзелФормата.ДочерниеУзлы[3].ТекстовоеСодержимое;
		Если ИмяПоля <> "" Тогда
			
			НовоеПоле = ТаблицаФормаЗаписи.Добавить();
			НовоеПоле.ИмяПоля = СокрЛП(ИмяПоля);
			// Тип данных хранится во 2-ой колонке.
			НовоеПоле.ТипДанных = ВРег(УзелФормата.ДочерниеУзлы[1].ТекстовоеСодержимое);
			
			НовоеПоле.НеВыводитьВФайл = Ложь;
			
			Если УзелФормата.ДочерниеУзлы.Количество() = 7 И УзелФормата.ДочерниеУзлы[6].ИмяУзла = "ТипЭлемента" Тогда
				НовоеПоле.ТипЭлемента = ВРег(УзелФормата.ДочерниеУзлы[6].ТекстовоеСодержимое);
			Иначе
				НовоеПоле.ТипЭлемента = "С";
			КонецЕсли;	
			
			// Размер поля хранится в 3-ей колонке.
			СтрРазмерПоля = УзелФормата.ДочерниеУзлы[2].ТекстовоеСодержимое;
			// Если указан размер поля, сохраним его.
			Если (НовоеПоле.ТипДанных = "ЧИСЛО" Или НовоеПоле.ТипДанных = "СТРОКА") И СтрРазмерПоля <> "" Тогда
				ПозицияТочки = Найти(СтрРазмерПоля,".");
				Если ПозицияТочки<>0 Тогда
					НовоеПоле.Размер = Число(Лев(СтрРазмерПоля,ПозицияТочки-1));
					НовоеПоле.РазрядностьДробнойЧасти = Число(Сред(СтрРазмерПоля,ПозицияТочки+1));
				Иначе	
					НовоеПоле.Размер = Число(СтрРазмерПоля);
					НовоеПоле.РазрядностьДробнойЧасти = 0;
				КонецЕсли;	 
			КонецЕсли;	 
			// Признак обязательности элемента хранится в 5-й колонке.
			НовоеПоле.ЭлементНеОбязателен = (ВРег(УзелФормата.ДочерниеУзлы[4].ТекстовоеСодержимое) = "НЕ ОБЯЗАТЕЛЬНО" Или ВРег(УзелФормата.ДочерниеУзлы[4].ТекстовоеСодержимое) = "Н");
			
		КонецЕсли;	 
		
	КонецЦикла;
	
	Возврат ТаблицаФормаЗаписи;
КонецФункции

Функция ИменаПолейСТипом(ИмяТаблицы, ТипДанных, КешПолейТаблиц = Неопределено, СтрокаИсключений = "")
	ИменаПолей = Новый Массив;
	
	ТекстЗапроса = СтрЗаменить("ВЫБРАТЬ * ИЗ ТаблицаВыборки КАК Т ГДЕ ЛОЖЬ", "ТаблицаВыборки", ИмяТаблицы);
	Если Неопределено <> КешПолейТаблиц Тогда
		ПоляТаблицы = КешПолейТаблиц.Получить(ИмяТаблицы);
		Если Неопределено = ПоляТаблицы Тогда
			Запрос = Новый Запрос(ТекстЗапроса);
			ПоляТаблицы = Запрос.Выполнить().Колонки;
			КешПолейТаблиц.Вставить(ИмяТаблицы, ПоляТаблицы);
		КонецЕсли;
	Иначе
		Запрос = Новый Запрос(ТекстЗапроса);
		ПоляТаблицы = Запрос.Выполнить().Колонки;
	КонецЕсли;
	
	Исключения = Новый Структура(СтрокаИсключений);
	Для Каждого Поле Из ПоляТаблицы Цикл
		Если Поле.ТипЗначения.СодержитТип(ТипДанных) И Не Исключения.Свойство(Поле.Имя) Тогда
			ИменаПолей.Добавить(Поле.Имя);
		КонецЕсли;
	КонецЦикла;
	
    Возврат ИменаПолей;
КонецФункции

Процедура ЗаменитьЗначение(Данные, ИменаПолей, Замещаемое, Заменитель, ЗначениеЗаменено = Ложь)
	Для Каждого ИмяПоля Из ИменаПолей Цикл
		Если Данные[ИмяПоля] = Замещаемое Тогда
			Данные[ИмяПоля] = Заменитель;
			ЗначениеЗаменено = Истина;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Процедура ЗаписатьДанные(Данные, Принудительно = Ложь)
	Если Данные.Модифицированность() Или Принудительно Тогда
		Данные.ОбменДанными.Загрузка = Истина;
		Данные.Записать();
	КонецЕсли;
КонецПроцедуры

Функция ОтборыРегистраСведений(МетаданныеРегистра, Запись)
	Отборы = Новый Структура;
	Если МетаданныеРегистра.ПериодичностьРегистраСведений <> Метаданные.СвойстваОбъектов.ПериодичностьРегистраСведений.Непериодический Тогда
		Отборы.Вставить("Период", Запись.Период);
	КонецЕсли;
	Для Каждого Измерение Из МетаданныеРегистра.Измерения Цикл
		Отборы.Вставить(Измерение.Имя, Запись[Измерение.Имя]);
	КонецЦикла;
	Возврат Отборы;
КонецФункции

Функция НаборЗаписей(МенеджерРегистра, Отборы)
	Набор = МенеджерРегистра.СоздатьНаборЗаписей();
	Для Каждого Отбор Из Отборы Цикл
		Набор.Отбор[Отбор.Ключ].Установить(Отбор.Значение);
	КонецЦикла;
	Набор.Прочитать();
	Возврат Набор;
КонецФункции

Функция ЭтоСсылочныйОбъектМетаданных(ОбъектМетаданных)
	Возврат Метаданные.Справочники.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.Документы.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.Перечисления.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыВидовХарактеристик.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыСчетов.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыВидовРасчета.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.БизнесПроцессы.Содержит(ОбъектМетаданных)
		//ИЛИ БизнесПроцессы.ТипВсеСсылкиТочекМаршрутаБизнесПроцессов().СодержитТип(Тип)
		ИЛИ Метаданные.Задачи.Содержит(ОбъектМетаданных)
		ИЛИ Метаданные.ПланыОбмена.Содержит(ОбъектМетаданных);
КонецФункции

// Возвращает поля представления по метаданным, используется при обработке получения данных выбора.
Функция ПоляПредставления(МетаданныеОбъекта)
	
	ПоляПредставления = Новый Структура("ПолеОсновногоПредставления,ПолеДопПредставления","","");
	
	Если МетаданныеОбъекта.ОсновноеПредставление = Метаданные.СвойстваОбъектов.ОсновноеПредставлениеСправочника.ВВидеНаименования 
		И МетаданныеОбъекта.ДлинаНаименования > 0 Тогда 
		ПоляПредставления.ПолеОсновногоПредставления = "Наименование";
		Если МетаданныеОбъекта.ДлинаКода > 0 Тогда
			ПоляПредставления.ПолеДопПредставления = "Код";
		КонецЕсли;
	ИначеЕсли МетаданныеОбъекта.ДлинаКода > 0 Тогда
		ПоляПредставления.ПолеОсновногоПредставления = "Код";
		Если МетаданныеОбъекта.ДлинаНаименования > 0 Тогда
			ПоляПредставления.ПолеДопПредставления = "Наименование";
		КонецЕсли;
	КонецЕсли;
	
	Возврат ПоляПредставления;	
	
КонецФункции

// Возвращает представления выбираемого элемента, используется при обработке получения данных выбора.
Функция ПредставлениеВыбираемогоЭлемента(Выборка, ПоляПредставления, ПолеПоиска = Неопределено)
	
	Представление = "";
	
	Если ПолеПоиска = Неопределено Тогда
		Если ПустаяСтрока(ПоляПредставления.ПолеДопПредставления) Тогда
			Представление = СокрЛП(Выборка[ПоляПредставления.ПолеОсновногоПредставления]);
		Иначе
			Представление = СокрЛП(Выборка[ПоляПредставления.ПолеОсновногоПредставления]) + " (" + СокрЛП(Выборка[ПоляПредставления.ПолеДопПредставления]) + ")";
		КонецЕсли;
	Иначе 		
		Если ПоляПредставления.ПолеОсновногоПредставления = ПолеПоиска Тогда
			Если ПустаяСтрока(ПоляПредставления.ПолеДопПредставления) Тогда
				Представление = СокрЛП(Выборка[ПоляПредставления.ПолеОсновногоПредставления]);
			Иначе
				Представление = СокрЛП(Выборка[ПоляПредставления.ПолеОсновногоПредставления]) + " (" + СокрЛП(Выборка[ПоляПредставления.ПолеДопПредставления]) + ")";
			КонецЕсли;
		ИначеЕсли ПоляПредставления.ПолеДопПредставления = ПолеПоиска Тогда
			Представление = Выборка[ПоляПредставления.ПолеДопПредставления] + " (" + СокрЛП(Выборка[ПоляПредставления.ПолеОсновногоПредставления]) + ")";
		Иначе
			Представление = Выборка.ПолеПоиска + " (" + СокрЛП(Выборка[ПоляПредставления.ПолеОсновногоПредставления]) + ")";
		КонецЕсли; 
	КонецЕсли;
	
	Возврат Представление;	
	
КонецФункции 

// Возвращает структуру простейшего элемента меню.
//
// Параметры:
//			ВидЭлемента - значения системных перечислений:
//						ВидГруппыФормы.Подменю
//						ВидКнопкиФормы.КнопкаКоманднойПанели.
//			Заголовок
//
// ВозвращаемоеЗначение:
//			Структура - содержит ключи Вид и Заголовок.
//
Функция ЭлементМеню(ВидЭлемента = Неопределено, Заголовок = "")
	
	ОписаниеЭлемента = Новый Структура;
	ОписаниеЭлемента.Вставить("Вид", ВидЭлемента);
	ОписаниеЭлемента.Вставить("Заголовок", Заголовок);
	
	Возврат ОписаниеЭлемента;
	
КонецФункции

#Область РасчетПериодовСостоянийСотрудников

#Область ВыборкаДанныхИзПервичногоРегистра

Функция ВыборкаИсходныхДанныхСостояний(ОписаниеРегистра, ЗначенияИзмерений = Неопределено)
	Запрос = Новый Запрос;
	Если ЗначенияИзмерений <> Неопределено Тогда
		Запрос.УстановитьПараметр("ЗначенияИзмерений", ЗначенияИзмерений);
	КонецЕсли;
	
	Запрос.Текст = ТекстЗапросаКИсходнымДаннымСостояний(ОписаниеРегистра, ЗначенияИзмерений);
	
	Возврат Запрос.Выполнить().Выбрать();
КонецФункции	

Функция ТекстЗапросаКИсходнымДаннымСостояний(ОписаниеРегистра, ЗначенияИзмерений)
	ТекстЗапроса = 
	"ВЫБРАТЬ
	|	ДанныеПервичногоРегистра.ЗначенияИзмерений КАК ЗначенияИзмерений_,
	|	ДанныеПервичногоРегистра.Приоритет_ КАК Приоритет,
	|	ДанныеПервичногоРегистра.Начало_ КАК Начало,
	|	ДанныеПервичногоРегистра.ДатаНачалаСобытия_ КАК ДатаНачалаСобытия,
	|	ДанныеПервичногоРегистра.Окончание_ КАК Окончание,
	|	СУММА(ВЫБОР
	|			КОГДА ДанныеПервичногоРегистра.Сторно
	|				ТОГДА -1
	|			ИНАЧЕ 1
	|		КОНЕЦ) КАК Сторно,
	|	ДанныеПервичногоРегистра.Ресурсы КАК Ресурсы_,
	|	ДанныеПервичногоРегистра.ИспользованиеРесурсов КАК ИспользованиеРесурсов_
	|ПОМЕСТИТЬ ВТДанныеПервичногоРегистра
	|ИЗ
	|	#ДанныеПервичногоРегистра КАК ДанныеПервичногоРегистра
	|ГДЕ
	|	&УсловиеОтбора
	|
	|СГРУППИРОВАТЬ ПО
	|	ДанныеПервичногоРегистра.ЗначенияИзмерений,
	|	ДанныеПервичногоРегистра.Приоритет_,
	|	ДанныеПервичногоРегистра.Начало_,
	|	ДанныеПервичногоРегистра.ДатаНачалаСобытия_,
	|	ДанныеПервичногоРегистра.Окончание_,
	|	ДанныеПервичногоРегистра.Ресурсы,
	|	ДанныеПервичногоРегистра.ИспользованиеРесурсов
	|
	|ИМЕЮЩИЕ
	|	СУММА(ВЫБОР
	|			КОГДА ДанныеПервичногоРегистра.Сторно
	|				ТОГДА -1
	|			ИНАЧЕ 1
	|		КОНЕЦ) > 0
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ДанныеНачалаИнтервалов.ЗначенияИзмерений_ КАК ЗначенияИзмерений_,
	|	СостоянияСотрудника.Порядок КАК Приоритет,
	|	ДанныеНачалаИнтервалов.Начало КАК Дата,
	|	ДанныеНачалаИнтервалов.ДатаНачалаСобытия,
	|	ДанныеНачалаИнтервалов.Окончание КАК ДействуетДо,
	|	ДанныеНачалаИнтервалов.Ресурсы_,
	|	ДанныеНачалаИнтервалов.ИспользованиеРесурсов_,
	|	ИСТИНА КАК ЭтоНачалоИнтервала
	|ИЗ
	|	ВТДанныеПервичногоРегистра КАК ДанныеНачалаИнтервалов
	|		ЛЕВОЕ СОЕДИНЕНИЕ Перечисление.СостоянияСотрудника КАК СостоянияСотрудника
	|		ПО ДанныеНачалаИнтервалов.Приоритет = СостоянияСотрудника.Ссылка
	|
	|ОБЪЕДИНИТЬ ВСЕ
	|
	|ВЫБРАТЬ
	|	ДанныеОкончанияИнтервалов.ЗначенияИзмерений_,
	|	0,
	|	ДанныеОкончанияИнтервалов.Окончание,
	|	NULL,
	|	NULL,
	|	ДанныеОкончанияИнтервалов.Ресурсы_,
	|	ДанныеОкончанияИнтервалов.ИспользованиеРесурсов_,
	|	ЛОЖЬ
	|ИЗ
	|	ВТДанныеПервичногоРегистра КАК ДанныеОкончанияИнтервалов
	|ГДЕ
	|	ДанныеОкончанияИнтервалов.Окончание <> ДАТАВРЕМЯ(1, 1, 1)
	|
	|УПОРЯДОЧИТЬ ПО
	|	ЗначенияИзмерений_,
	|	Дата,
	|	ЭтоНачалоИнтервала УБЫВ,
	|	Приоритет";			
	
	// условие отбора
	Если ЗначенияИзмерений <> Неопределено Тогда
		ДобавитьУсловиеВЗапросКИсходнымДаннымСостояний(ТекстЗапроса, ЗначенияИзмерений);	
	Иначе
		ТекстУсловия = "ИСТИНА";
		ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбора", ТекстУсловия);
	КонецЕсли;
	
	// источник данных
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "#ДанныеПервичногоРегистра", "РегистрСведений." + ОписаниеРегистра.ИмяРегистра);
	// приоритет
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ДанныеПервичногоРегистра.Приоритет_ КАК Приоритет", "ДанныеПервичногоРегистра." + ОписаниеРегистра.ИмяПоляПриоритет + " КАК Приоритет");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ДанныеПервичногоРегистра.Приоритет_", "ДанныеПервичногоРегистра." + ОписаниеРегистра.ИмяПоляПриоритет);
	// начало
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ДанныеПервичногоРегистра.Начало_ КАК Начало", "ДанныеПервичногоРегистра." + ОписаниеРегистра.ИмяПоляДатаНачалаПериода + " КАК Начало");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ДанныеПервичногоРегистра.Начало_", "ДанныеПервичногоРегистра." + ОписаниеРегистра.ИмяПоляДатаНачалаПериода);
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ДанныеПервичногоРегистра.ДатаНачалаСобытия_ КАК ДатаНачалаСобытия", "ДанныеПервичногоРегистра." + ОписаниеРегистра.ИмяПоляДатаНачалаСобытия + " КАК ДатаНачалаСобытия");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ДанныеПервичногоРегистра.ДатаНачалаСобытия_", "ДанныеПервичногоРегистра." + ОписаниеРегистра.ИмяПоляДатаНачалаСобытия);

	// окончание
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ДанныеПервичногоРегистра.Окончание_ КАК Окончание", "ДанныеПервичногоРегистра." + ОписаниеРегистра.ИмяПоляДатаОкончанияПериода + " КАК Окончание");
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ДанныеПервичногоРегистра.Окончание_", "ДанныеПервичногоРегистра." + ОписаниеРегистра.ИмяПоляДатаОкончанияПериода);

	// измерения
	
	ПоляИзмеренияТекст = "";
	ПоляИзмеренияПорядокТекст = "";
	ПоляИзмеренияНачалоИнтерваловТекст = "";
	ПоляИзмеренияОкончанияИнтерваловТекст = "";
	Для Каждого ИзмерениеРегистра Из ОписаниеРегистра.Измерения Цикл
		ПоляИзмеренияТекст = ПоляИзмеренияТекст + ",
					  		 |	ДанныеПервичногоРегистра." + ИзмерениеРегистра;
							 
		ПоляИзмеренияПорядокТекст = ПоляИзмеренияПорядокТекст + ",
									|	" + ИзмерениеРегистра;
							 
		ПоляИзмеренияНачалоИнтерваловТекст = ПоляИзмеренияНачалоИнтерваловТекст + ",
					  						 |	ДанныеНачалаИнтервалов." + ИзмерениеРегистра;	
											 
		ПоляИзмеренияОкончанияИнтерваловТекст = ПоляИзмеренияОкончанияИнтерваловТекст + ",
					  							|	ДанныеОкончанияИнтервалов." + ИзмерениеРегистра;									 
	КонецЦикла;	
						 
	ПоляИзмеренияТекст = Сред(ПоляИзмеренияТекст, 2);
	ПоляИзмеренияПорядокТекст = Сред(ПоляИзмеренияПорядокТекст, 2);
	ПоляИзмеренияНачалоИнтерваловТекст = Сред(ПоляИзмеренияНачалоИнтерваловТекст, 2);
	ПоляИзмеренияОкончанияИнтерваловТекст = Сред(ПоляИзмеренияОкончанияИнтерваловТекст, 2);
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ДанныеПервичногоРегистра.ЗначенияИзмерений КАК ЗначенияИзмерений_", ПоляИзмеренияТекст);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ДанныеПервичногоРегистра.ЗначенияИзмерений", ПоляИзмеренияТекст);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ДанныеНачалаИнтервалов.ЗначенияИзмерений_ КАК ЗначенияИзмерений_", ПоляИзмеренияНачалоИнтерваловТекст);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ДанныеОкончанияИнтервалов.ЗначенияИзмерений_", ПоляИзмеренияОкончанияИнтерваловТекст);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ЗначенияИзмерений_", ПоляИзмеренияПорядокТекст);

	// ресурсы
    
    МетаданныеРегистра = Метаданные.РегистрыСведений[ОписаниеРегистра.ИмяРегистра];
    ПоляРегистра = Новый Соответствие;
    
    Для Каждого Измерение Из МетаданныеРегистра.Измерения Цикл
    	ПоляРегистра.Вставить(Измерение.Имя, Истина);	
    КонецЦикла;	
    
    Для Каждого Ресурс Из МетаданныеРегистра.Ресурсы Цикл
    	ПоляРегистра.Вставить(Ресурс.Имя, Истина);	
    КонецЦикла;	
    
    Для Каждого Реквизит Из МетаданныеРегистра.Реквизиты Цикл
    	ПоляРегистра.Вставить(Реквизит.Имя, Истина);	
    КонецЦикла;	

    ПоляРесурсов = "";
    ПоляИспользованияРесурсов = "";
    ПоляИспользованияРесурсовГруппировка = "";
	ПоляРесурсовНачалоИнтерваловТекст = "";
	ПоляРесурсовОкончаниеИнтерваловТекст = "";
	ПоляИспользованиеРесурсовНачалоИнтерваловТекст = "";
	ПоляИспользованиеРесурсовОкончаниеИнтерваловТекст = "";
    Для Каждого ОписаниеРесурсаРегистра Из ОписаниеРегистра.Ресурсы Цикл
    	ПоляРесурсов = ПоляРесурсов + ",
    				   |	ДанныеПервичногоРегистра." + ОписаниеРесурсаРегистра;
					   
		ПоляРесурсовНачалоИнтерваловТекст = ПоляРесурсовНачалоИнтерваловТекст + ",
    				  						|	ДанныеНачалаИнтервалов." + ОписаниеРесурсаРегистра;	
											
		ПоляРесурсовОкончаниеИнтерваловТекст = ПоляРесурсовОкончаниеИнтерваловТекст + ",
    				  						   |	NULL";										
    				   
    	ИмяПоляИспользованияРесурса = "ИспользованиеРесурса" + ОписаниеРесурсаРегистра; 
		
		ПоляИспользованиеРесурсовОкончаниеИнтерваловТекст = ПоляИспользованиеРесурсовОкончаниеИнтерваловТекст + ",
    				  										|	ЗНАЧЕНИЕ(Перечисление.ЗначениеРесурсаРегистровСостоянийСотрудника.НеУстановлено) КАК " + ИмяПоляИспользованияРесурса;
    				   
    	Если ПоляРегистра.Получить(ИмяПоляИспользованияРесурса) = Неопределено Тогда
    		ПоляИспользованияРесурсов = ПоляИспользованияРесурсов + ",
    				  						 	|	ЗНАЧЕНИЕ(Перечисление.ЗначениеРесурсаРегистровСостоянийСотрудника.Установлено) КАК " + ИмяПоляИспользованияРесурса;
												
			ПоляИспользованиеРесурсовНачалоИнтерваловТекст = ПоляИспользованиеРесурсовНачалоИнтерваловТекст + ",
    				  										|	ЗНАЧЕНИЕ(Перечисление.ЗначениеРесурсаРегистровСостоянийСотрудника.Установлено) КАК " + ИмяПоляИспользованияРесурса;									
												
			ПоляИспользованияРесурсовГруппировка = ПоляИспользованияРесурсовГруппировка + ",
    				  							   |	ЗНАЧЕНИЕ(Перечисление.ЗначениеРесурсаРегистровСостоянийСотрудника.Установлено)";									
    	Иначе
    		ПоляИспользованияРесурсов = ПоляИспользованияРесурсов + ",
    				  							|	ДанныеПервичногоРегистра." + ИмяПоляИспользованияРесурса;
												
			ПоляИспользованиеРесурсовНачалоИнтерваловТекст = ПоляИспользованиеРесурсовНачалоИнтерваловТекст + ",
    				  										|	ДанныеНачалаИнтервалов." + ИмяПоляИспользованияРесурса;											
												
    		ПоляИспользованияРесурсовГруппировка = ПоляИспользованияРесурсовГруппировка + ",
    				  									   |	ДанныеПервичногоРегистра." + ИмяПоляИспользованияРесурса;
    	КонецЕсли;
    КонецЦикла;	
    
    ПоляРесурсов = Сред(ПоляРесурсов, 2);
    ПоляИспользованияРесурсов = Сред(ПоляИспользованияРесурсов, 2);
	ПоляИспользованияРесурсовГруппировка = Сред(ПоляИспользованияРесурсовГруппировка, 2);
    ПоляРесурсовНачалоИнтерваловТекст = Сред(ПоляРесурсовНачалоИнтерваловТекст, 2);
	ПоляРесурсовОкончаниеИнтерваловТекст = Сред(ПоляРесурсовОкончаниеИнтерваловТекст, 2);
	ПоляИспользованиеРесурсовНачалоИнтерваловТекст = Сред(ПоляИспользованиеРесурсовНачалоИнтерваловТекст, 2);
	ПоляИспользованиеРесурсовОкончаниеИнтерваловТекст = Сред(ПоляИспользованиеРесурсовОкончаниеИнтерваловТекст, 2);
    
    ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ДанныеПервичногоРегистра.Ресурсы КАК Ресурсы_", ПоляРесурсов);
    ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ДанныеПервичногоРегистра.ИспользованиеРесурсов КАК ИспользованиеРесурсов_", ПоляИспользованияРесурсов);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ДанныеПервичногоРегистра.Ресурсы", ПоляРесурсов);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ДанныеПервичногоРегистра.ИспользованиеРесурсов", ПоляИспользованияРесурсовГруппировка);
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ДанныеНачалаИнтервалов.Ресурсы_", ПоляРесурсовНачалоИнтерваловТекст);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ДанныеНачалаИнтервалов.ИспользованиеРесурсов_", ПоляИспользованиеРесурсовНачалоИнтерваловТекст);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ДанныеОкончанияИнтервалов.Ресурсы_", ПоляРесурсовОкончаниеИнтерваловТекст);
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "ДанныеОкончанияИнтервалов.ИспользованиеРесурсов_", ПоляИспользованиеРесурсовОкончаниеИнтерваловТекст);
  	
	Возврат ТекстЗапроса;
КонецФункции	

Процедура ДобавитьУсловиеВЗапросКИсходнымДаннымСостояний(ТекстЗапроса, ЗначенияИзмерений)
	ТекстЗапросаВыбораЗначенийИзмерений = 
	"ВЫБРАТЬ
	|	ТаблицаОтбора.ЗначенияИзмерений
	|ПОМЕСТИТЬ ВТТаблицаОтбора
	|ИЗ
	|	&ЗначенияИзмерений КАК ТаблицаОтбора";
	
	ПоляТаблицыИзмеренийТекст = "";
	ПоляИзмеренийПервичногоРегистра = "";
	Для Каждого ОписаниеКолонкиТаблицыОтбора Из ЗначенияИзмерений.Колонки Цикл
		ПоляТаблицыИзмеренийТекст = ПоляТаблицыИзмеренийТекст + ",
									|	ТаблицаОтбора." + ОписаниеКолонкиТаблицыОтбора.Имя;	
									
		ПоляИзмеренийПервичногоРегистра = ПоляИзмеренийПервичногоРегистра + ", ДанныеПервичногоРегистра." + ОписаниеКолонкиТаблицыОтбора.Имя;								
	КонецЦикла;	
	
	ПоляТаблицыИзмеренийТекст = Сред(ПоляТаблицыИзмеренийТекст, 2);
	ПоляИзмеренийПервичногоРегистра = Сред(ПоляИзмеренийПервичногоРегистра, 2);
	
	ТекстЗапросаВыбораЗначенийИзмерений = СтрЗаменить(ТекстЗапросаВыбораЗначенийИзмерений, "ТаблицаОтбора.ЗначенияИзмерений", ПоляТаблицыИзмеренийТекст);	
	
	ТекстЗапроса = ТекстЗапросаВыбораЗначенийИзмерений + ";
					|
					|" + ТекстЗапроса;
	
	УсловиеОтбораТекст = "(ДанныеПервичногоРегистра.ЗначенияИзмерений) В
						 |	(ВЫБРАТЬ
						 | 		ТаблицаОтбора.ЗначенияИзмерений
						 |	ИЗ
						 |		ВТТаблицаОтбора КАК ТаблицаОтбора)";	
						 
	УсловиеОтбораТекст = СтрЗаменить(УсловиеОтбораТекст, "ТаблицаОтбора.ЗначенияИзмерений", ПоляТаблицыИзмеренийТекст); 
	УсловиеОтбораТекст = СтрЗаменить(УсловиеОтбораТекст, "ДанныеПервичногоРегистра.ЗначенияИзмерений", ПоляИзмеренийПервичногоРегистра); 
	
	ТекстЗапроса = СтрЗаменить(ТекстЗапроса, "&УсловиеОтбора", УсловиеОтбораТекст);
КонецПроцедуры	

Функция ТаблицаИсходныхДанныхСостояний(ОписаниеРегистра)
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Дата", Новый ОписаниеТипов("Дата"));
	Таблица.Колонки.Добавить("ДатаНачалаСобытия", Новый ОписаниеТипов("Дата"));
	Таблица.Колонки.Добавить("ДействуетДо", Новый ОписаниеТипов("Дата"));
	Таблица.Колонки.Добавить("ЭтоНачалоИнтервала", Новый ОписаниеТипов("Булево"));
	Таблица.Колонки.Добавить("Приоритет", Новый ОписаниеТипов("Число"));

	Для Каждого ИзмерениеРегистра Из ОписаниеРегистра.Измерения Цикл                             
		Таблица.Колонки.Добавить(ИзмерениеРегистра);
	КонецЦикла;	

	Для Каждого РесурсРегистра Из ОписаниеРегистра.Ресурсы Цикл                             
		Таблица.Колонки.Добавить(РесурсРегистра);
		Таблица.Колонки.Добавить("ИспользованиеРесурса" + РесурсРегистра, Новый ОписаниеТипов("ПеречислениеСсылка.ЗначениеРесурсаРегистровСостоянийСотрудника"));
	КонецЦикла;	
		
	Возврат Таблица;
КонецФункции

#КонецОбласти

#Область МетодыДляРаботыСВыборкойДанныхПервичногоРегистра

Функция ЗначенияИзмеренийПериодовСостояний(ОписаниеРегистра)
	СтруктураЗначенийИзмерений = Новый Структура;
	
	Для Каждого Измерение Из ОписаниеРегистра.Измерения Цикл
		СтруктураЗначенийИзмерений.Вставить(Измерение);			
	КонецЦикла;	
	
	Возврат СтруктураЗначенийИзмерений;
КонецФункции	

Функция ЗначенияИзмеренийЗаписейСостоянийОтличны(ТекущиеЗначенияИзмерений, ВыборкаДанныхПервичногоРегистра)
	Для Каждого КлючЗначение Из ТекущиеЗначенияИзмерений Цикл
		Если КлючЗначение.Значение <> ВыборкаДанныхПервичногоРегистра[КлючЗначение.Ключ] Тогда
			Возврат Истина;
		КонецЕсли;	
	КонецЦикла;
	
	Возврат Ложь;
КонецФункции

#КонецОбласти

#Область ЗаписьРегистраВторичныхДанных

Процедура ЗаписатьНаборРегистраРассчитанныхПериодовСостояний(ЗначенияИзмеренийНабора, ОписаниеРегистраВторичныхДанных, РассчитанныеДанные = Неопределено, РежимЗагрузки = Ложь)
	МенеджерРегистра = ОбщегоНазначения.МенеджерОбъектаПоПолномуИмени("РегистрСведений." + ОписаниеРегистраВторичныхДанных.ИмяРегистра);
	
	НаборЗаписей = МенеджерРегистра.СоздатьНаборЗаписей();
	
	Если РежимЗагрузки Тогда
		НаборЗаписей.ОбменДанными.Загрузка = Истина;
	КонецЕсли;	
	
	Для Каждого ИзмерениеРегистра Из ОписаниеРегистраВторичныхДанных.Измерения Цикл
		НаборЗаписей.Отбор[ИзмерениеРегистра].Установить(ЗначенияИзмеренийНабора[ИзмерениеРегистра]);		
	КонецЦикла;	
	
	Если РассчитанныеДанные <> Неопределено Тогда
		Для Каждого СтрокаИтоговыхДанных Из РассчитанныеДанные Цикл
			ЗаписьНабора = НаборЗаписей.Добавить();
			ЗаполнитьЗначенияСвойств(ЗаписьНабора, СтрокаИтоговыхДанных);
			ЗаписьНабора[ОписаниеРегистраВторичныхДанных.ИмяПоляДатаНачалаПериода] = СтрокаИтоговыхДанных.Начало;
			ЗаписьНабора[ОписаниеРегистраВторичныхДанных.ИмяПоляДатаОкончанияПериода] = СтрокаИтоговыхДанных.Окончание;
		КонецЦикла;
	КонецЕсли;	
	
	НаборЗаписей.Записать();
		
КонецПроцедуры	

#КонецОбласти

#Область РасчетЗаписейРегистраВторичныхДанных

// В этой функции реализован алгоритм расчета данных вторичного регистра.
//
// Инициализация
//	Берем первую строку из обрабатываемого набора.
//	Открываем запись в регистре итоговых данных.
//
//	Цикл - выполняется пока мы не обработали все строки из входящего набора начинаем со второй строки.
//		-Закрываем предыдущую запись.
//  	-Если обрабатываемая дата - начало записи регистра первичных данных, то дата окончания предыдущей строки, равна
//   		обрабатываемая дата минус день, иначе дата окончания предыдущей даты равна обрабатываемой дате. 
//       
//			Цикл- для каждого ресурса.
//				-Получаем (и удаляем) значения из стэка в переменную (каждое значение в стэке это структура: Значение, Приоритет,
//				ДействуетДо), по сути, мы получаем значение ресурса, действующих на начало закрытой записи.
//				-Определяем нужно ли, помещать значение ресурса действующего на начало закрываемой записи и значение ресурса
//				самой записи в стэк - значения ресурса нужно помещать в стэк, если оно будет действовать по окончании закрываемой
//				записи и оно не ЕстьNull.
//				-Определяем порядок помещения ресурсов в стэк Т.к. получаем данные из стэка по принципу LIFO,
//					то помещаем значение ресурса действующего на начало закрываемой записи (при необходимости)  и значение ресурса
//					самой записи (при необходимости) , в порядке обратном приоритету.
//				-В итоге первое значение в стэке - это значение действующее по окончании закрываемой записи. Запомним эти
//				значения в переменную.
//
//        	Конец цикла - обход ресурсов завершен.
//
//			-Открываем новую запись  данных вторичного регистра.
//			-Заполняем значения ресурсов с учетом ресурсов действующих по завершении предыдущей записи (получены на предыдущем
//			этапе), берет то значение, приоритет которого выше.
//			-Сравниваем значения ресурсов и дату новой строки итоговых данных с данными предыдущей строки. 
//			-Если новая строка является продолжением предыдущей то новую строку в итоговые данные не добавляем, а продолжаем
//			предыдущую.
//			-Если все значения ресурсов в строке NULL, то эту строку в итоговые данные добавлять не нужно.
//	Конец цикла - обход строк входящего набора завершен.
//
Функция РассчитанныеПериодыСостояний(ДанныеПервичногоРегистра, ОписаниеРегистра) Экспорт
	МаксимальныйПриритет = ЗарплатаКадрыПовтИсп.МаксимальныйПриоритетСостоянийСотрудника();
	
	РесурсыРегистра = ОписаниеРегистра.Ресурсы;
	
	ТаблицаИтоговыхДанных = ТаблицаРассчитанныхПериодовСостояний(ОписаниеРегистра);
	
	СтэкиЗначенийРесурсов = СтэкиЗначенийРесурсовСостояний(РесурсыРегистра);
	
	ДанныеПредыдущегоИнтервала = Неопределено;	
	
	ПредыдущаяСтрока = Неопределено;
	ОбрабатываемаяДата = Неопределено;
	ЗарегистрировоНачальноеСобытие = Ложь;
	Для Каждого СтрокаДанныхПервичногоРегистра Из ДанныеПервичногоРегистра Цикл
		Если ОбрабатываемаяДата <> СтрокаДанныхПервичногоРегистра.Дата Тогда
			ОбрабатываемаяДата = СтрокаДанныхПервичногоРегистра.Дата;
			ЗарегистрировоНачальноеСобытие = Ложь;
		КонецЕсли;
		
		// обрабатываем ситуации когда было увольнение и прием на следующий день
		Если СтрокаДанныхПервичногоРегистра.Приоритет = 0 
			И СтрокаДанныхПервичногоРегистра.ЭтоНачалоИнтервала Тогда
			
			ЗарегистрировоНачальноеСобытие = Истина;
		ИначеЕсли ЗарегистрировоНачальноеСобытие
			И СтрокаДанныхПервичногоРегистра.Приоритет = МаксимальныйПриритет Тогда
			
			Продолжить;
		КонецЕсли;	
			
		Если ПредыдущаяСтрока <> Неопределено Тогда
			Если СтрокаДанныхПервичногоРегистра.ЭтоНачалоИнтервала Тогда
				ОкончаниеПредыдущейЗаписи = СтрокаДанныхПервичногоРегистра.Дата - 86400;
			Иначе 
				ОкончаниеПредыдущейЗаписи = СтрокаДанныхПервичногоРегистра.Дата;
			КонецЕсли;	
			
			ЗакрытьПредыдущийПериодДействияСостояния(ТаблицаИтоговыхДанных, ОкончаниеПредыдущейЗаписи);
			
			РесурсыДействующиеПоОкончании = РесурсыДействующиеПоЗавершениюТекущегоСостояния(
												ДанныеПредыдущегоИнтервала,
												СтэкиЗначенийРесурсов,
												ОкончаниеПредыдущейЗаписи,
												ОписаниеРегистра.Ресурсы);
												
		Иначе
			ДанныеПредыдущегоИнтервала = СтруктураЗаписиРассчитанныхПериодовСостояний(ОписаниеРегистра);
		КонецЕсли;
		                                            
		Если ОкончаниеПредыдущейЗаписи = Неопределено
			Или СтрокаДанныхПервичногоРегистра.Дата >= ОкончаниеПредыдущейЗаписи Тогда
			
			НоваяСтрока = ДобавитьЗаписьВРассчитанныеПериодыСостояний(ОписаниеРегистра, ТаблицаИтоговыхДанных, СтрокаДанныхПервичногоРегистра, РесурсыДействующиеПоОкончании);
				
			ПредыдущаяСтрока = НоваяСтрока;	
		КонецЕсли;	
		
		ЗаполнитьЗначенияСвойств(ДанныеПредыдущегоИнтервала, СтрокаДанныхПервичногоРегистра);
		ДанныеПредыдущегоИнтервала.Начало = СтрокаДанныхПервичногоРегистра.Дата;
	КонецЦикла;	  
	
	Возврат ТаблицаИтоговыхДанных;
КонецФункции	

Функция СтэкиЗначенийРесурсовСостояний(ОписаниеРесурсов)
	Стэки = Новый Соответствие;
		
	Для Каждого Ресурс Из ОписаниеРесурсов Цикл
		Стэки.Вставить(Ресурс, Новый Массив);
	КонецЦикла;	
	
	Возврат Стэки;
	
КонецФункции	

Процедура ЗакрытьПредыдущийПериодДействияСостояния(ИтоговыеДанные, ДатаОкончанияЗаписи)
	СтрокаТаблицыИтоговыхДанных = ИтоговыеДанные[ИтоговыеДанные.Количество() - 1];
	
	// Обработаем ситуацию, когда несколько записей начинаются в одну и туже дату.
	Если СтрокаТаблицыИтоговыхДанных.Начало > ДатаОкончанияЗаписи Тогда
		ИтоговыеДанные.Удалить(ИтоговыеДанные.Количество() - 1);
	Иначе	
		СтрокаТаблицыИтоговыхДанных.Окончание = ДатаОкончанияЗаписи;
	КонецЕсли;	
				
КонецПроцедуры	

Функция РесурсыДействующиеПоЗавершениюТекущегоСостояния(ДанныеЗавершаемойЗаписи, СтэкиЗначенийРесурсов, ДатаОкончанияЗаписи, РесурсыРегистра)
	РесурсыДействующиеПоОкончании = Новый Структура;
	
	Для Каждого ОписаниеРесурса Из РесурсыРегистра Цикл
		СтэкЗначенийТекущегоРесурса = СтэкиЗначенийРесурсов[ОписаниеРесурса];
		
		СозранитьРесурсыДействующиеПоЗавершенииТекущегоСостояния(
			СтэкЗначенийТекущегоРесурса, 
			ОписаниеРесурса, 
			ДанныеЗавершаемойЗаписи,
			ДатаОкончанияЗаписи);	
			
		// Первые значения в стэке - это и есть значения ресурсов которые,
		// будет действовать по окончании записи.
		Если СтэкЗначенийТекущегоРесурса.Количество() > 0 Тогда 
			РесурсыДействующиеПоОкончании.Вставить(ОписаниеРесурса, СтэкЗначенийТекущегоРесурса[0]);	
		КонецЕсли;	
	КонецЦикла;	
	
	Возврат РесурсыДействующиеПоОкончании;
КонецФункции	

Процедура СозранитьРесурсыДействующиеПоЗавершенииТекущегоСостояния(Стэк, Ресурс, ДанныеЗакрываемойЗаписи, ДатаОкончанияЗаписи)
	
	// Первое значение в стэке - это значение ресурса действующее до начала предыдущей записи.
	Если Стэк.Количество() > 0 Тогда
		ПредыдущееЗначениеРесурса = Стэк[0];
		Стэк.Удалить(0);
	Иначе
		ПредыдущееЗначениеРесурса = Неопределено;
	КонецЕсли;
	
	// Определим порядок помещения значений ресурса действующих по завершении записи в стэк
	// и поместим эти значения.
	Если ПриоритетПредыдущегоСостоянияВыше(Ресурс, ПредыдущееЗначениеРесурса, ДанныеЗакрываемойЗаписи) Тогда
		Если ЗначениеРесурсаЗакрываемогоСостоянияДействуетПоОкончании(Ресурс, ДанныеЗакрываемойЗаписи, ПредыдущееЗначениеРесурса, ДатаОкончанияЗаписи) Тогда
			СозранитьЗначениеРесурсаЗакрываемогоСостояния(Стэк, Ресурс, ДанныеЗакрываемойЗаписи, ПредыдущееЗначениеРесурса, ДатаОкончанияЗаписи);
		КонецЕсли;	
		
		СозранитьЗначениеРесурсаПередыдущегоСостояния(Стэк, Ресурс, ДанныеЗакрываемойЗаписи, ПредыдущееЗначениеРесурса, ДатаОкончанияЗаписи);
	Иначе
		Если ЗначениеРесурсаПердыдущегоСостоянияДействуетПоОкончании(Ресурс, ДанныеЗакрываемойЗаписи, ПредыдущееЗначениеРесурса, ДатаОкончанияЗаписи) Тогда 
			СозранитьЗначениеРесурсаПередыдущегоСостояния(Стэк, Ресурс, ДанныеЗакрываемойЗаписи, ПредыдущееЗначениеРесурса, ДатаОкончанияЗаписи);
		КонецЕсли;
		
		СозранитьЗначениеРесурсаЗакрываемогоСостояния(Стэк, Ресурс, ДанныеЗакрываемойЗаписи, ПредыдущееЗначениеРесурса, ДатаОкончанияЗаписи);		
		
	КонецЕсли;	
	
КонецПроцедуры	

Функция ПриоритетПредыдущегоСостоянияВыше(ОписаниеРесурса, ПредыдущееЗначениеРесурса, ДанныеЗакрываемойЗаписи)
	Если ПредыдущееЗначениеРесурса = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если Не ЗначениеРесурсаЗаписиСостоянияУстановлено(ДанныеЗакрываемойЗаписи, ОписаниеРесурса) Тогда
		Возврат Истина;			
	КонецЕсли;
	
	Если ПредыдущееЗначениеРесурса.ДатаНачалаСобытия > ДанныеЗакрываемойЗаписи.ДатаНачалаСобытия
		И ДанныеЗакрываемойЗаписи.Приоритет = ПредыдущееЗначениеРесурса.Приоритет Тогда
		
		Возврат Истина;
	КонецЕсли;	
	
	Если ПредыдущееЗначениеРесурса.ДатаНачалаСобытия > ДанныеЗакрываемойЗаписи.ДатаНачалаСобытия
		И ДанныеЗакрываемойЗаписи.ДействуетДо = '00010101' Тогда
		
		Возврат Истина;
	КонецЕсли;	
	
	// Не закрытые записи всегда закрываются следующей внезависимости от приоритета.
	Если ПредыдущееЗначениеРесурса.ДействуетДо = '00010101' 
		И ДанныеЗакрываемойЗаписи.ДействуетДо = '00010101' 
		И ПредыдущееЗначениеРесурса.ДатаНачалаСобытия <> ДанныеЗакрываемойЗаписи.ДатаНачалаСобытия Тогда
		
		Возврат Ложь;
	КонецЕсли;		
		
	Если ДанныеЗакрываемойЗаписи.Приоритет >= ПредыдущееЗначениеРесурса.Приоритет Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли;		
КонецФункции	

Функция ЗначениеРесурсаПердыдущегоСостоянияДействуетПоОкончании(ОписаниеРесурса, ДанныеЗакрываемойЗаписи, ПредыдущееЗначениеРесурса, ДатаОкончанияЗаписи)
	Если ПредыдущееЗначениеРесурса <> Неопределено
		И ДатаДействияРесурсаБольше(ПредыдущееЗначениеРесурса.ДействуетДо, ДатаОкончанияЗаписи)
		И (Не ЗначениеРесурсаЗаписиСостоянияУстановлено(ДанныеЗакрываемойЗаписи, ОписаниеРесурса)
		Или Не ДатаДействияРесурсаБольшеИлиРавна(ДанныеЗакрываемойЗаписи.ДействуетДо, ПредыдущееЗначениеРесурса.ДействуетДо)) Тогда
		
		Возврат Истина;
	Иначе
		Возврат Ложь;
	КонецЕсли;			
КонецФункции	

Функция СозранитьЗначениеРесурсаПередыдущегоСостояния(Стэк, ОписаниеРесурса, ДанныеЗакрываемойЗаписи, ПредыдущееЗначениеРесурса, ДатаОкончанияЗаписи)	
	Если ПредыдущееЗначениеРесурса <> Неопределено
		И ДатаДействияРесурсаБольше(ПредыдущееЗначениеРесурса.ДействуетДо, ДатаОкончанияЗаписи) Тогда
				
		Стэк.Вставить(0, ПредыдущееЗначениеРесурса);
	КонецЕсли;	
	
	Возврат ПредыдущееЗначениеРесурса;
			
КонецФункции

Функция СозранитьЗначениеРесурсаЗакрываемогоСостояния(Стэк, ОписаниеРесурса, ДанныеЗакрываемойЗаписи, ПредыдущееЗначениеРесурса, ДатаОкончанияЗаписи)
	ЗначениеРесурса = Неопределено;
	Поля = "Значение, Приоритет, ДатаНачалаСобытия, ДействуетДо, Использование";
	
	Если ЗначениеРесурсаЗаписиСостоянияУстановлено(ДанныеЗакрываемойЗаписи, ОписаниеРесурса)
		И ДатаДействияРесурсаБольше(ДанныеЗакрываемойЗаписи.ДействуетДо, ДатаОкончанияЗаписи) Тогда
		
		ЗначениеРесурса = Новый Структура(Поля);
		ЗначениеРесурса.Значение = ДанныеЗакрываемойЗаписи[ОписаниеРесурса];
		ЗначениеРесурса.ДатаНачалаСобытия = ДанныеЗакрываемойЗаписи.ДатаНачалаСобытия;
		ЗначениеРесурса.ДействуетДо = ДанныеЗакрываемойЗаписи.ДействуетДо;
		ЗначениеРесурса.Приоритет = ДанныеЗакрываемойЗаписи.Приоритет;
		ЗначениеРесурса.Использование = ДанныеЗакрываемойЗаписи["ИспользованиеРесурса" + ОписаниеРесурса];
		
		Стэк.Вставить(0, ЗначениеРесурса);
	КонецЕсли;	

	Возврат ЗначениеРесурса;
КонецФункции	

Функция ЗначениеРесурсаЗакрываемогоСостоянияДействуетПоОкончании(ОписаниеРесурса, ДанныеЗакрываемойЗаписи, ПредыдущееЗначениеРесурса, ДатаОкончанияЗаписи)
	Если ЗначениеРесурсаЗаписиСостоянияУстановлено(ДанныеЗакрываемойЗаписи, ОписаниеРесурса)
		И ДатаДействияРесурсаБольше(ДанныеЗакрываемойЗаписи.ДействуетДо, ДатаОкончанияЗаписи)
		И (ПредыдущееЗначениеРесурса = Неопределено 
		Или ДатаДействияРесурсаБольше(ДанныеЗакрываемойЗаписи.ДействуетДо, ПредыдущееЗначениеРесурса.ДействуетДо)) Тогда
		
		Возврат Истина;	
	Иначе
		Возврат Ложь;
	КонецЕсли;	
	
	Возврат Ложь;

КонецФункции	

Функция ДобавитьЗаписьВРассчитанныеПериодыСостояний(ОписаниеРегистра, ИтоговыеДанные, СтрокаДанныхПервичногоРегистра, РесурсыДействующиеНаНачало = Неопределено)
	СтруктураДанныхТекущейСтроки = СтруктураЗаписиРассчитанныхПериодовСостояний(ОписаниеРегистра);
	
	ЗаполнитьЗначенияСвойств(СтруктураДанныхТекущейСтроки, СтрокаДанныхПервичногоРегистра);	
	
	Если СтрокаДанныхПервичногоРегистра.ЭтоНачалоИнтервала Тогда
		СтруктураДанныхТекущейСтроки.Начало = СтрокаДанныхПервичногоРегистра.Дата;
	Иначе	
		СтруктураДанныхТекущейСтроки.Начало = СтрокаДанныхПервичногоРегистра.Дата + 86400;
	КонецЕсли;	
	
	Для Каждого ОписаниеРесурса Из ОписаниеРегистра.Ресурсы Цикл
		ЗначениеРесурсаПредыдущее = Неопределено;
		Если РесурсыДействующиеНаНачало = Неопределено Тогда 
			ЗначениеРесурсаПредыдущее = Неопределено;	
		Иначе	
			РесурсыДействующиеНаНачало.Свойство(ОписаниеРесурса, ЗначениеРесурсаПредыдущее);
		КонецЕсли;	
		
		Если ПриоритетПредыдущегоСостоянияВыше(ОписаниеРесурса, ЗначениеРесурсаПредыдущее, СтрокаДанныхПервичногоРегистра)
			И ДатаДействияРесурсаБольшеИлиРавна(ЗначениеРесурсаПредыдущее.ДействуетДо, СтруктураДанныхТекущейСтроки.Начало) Тогда
			
			СтруктураДанныхТекущейСтроки[ОписаниеРесурса] = ЗначениеРесурсаПредыдущее.Значение;
			СтруктураДанныхТекущейСтроки["ИспользованиеРесурса" + ОписаниеРесурса] = ЗначениеРесурсаПредыдущее.Использование;
			
			Если ЗначениеРесурсаПредыдущее.Использование = Перечисления.ЗначениеРесурсаРегистровСостоянийСотрудника.Установлено Тогда
				СтруктураДанныхТекущейСтроки["ЗарегистрированоЗначение" + ОписаниеРесурса] = Истина;	
			КонецЕсли;	
		Иначе
			СтруктураДанныхТекущейСтроки[ОписаниеРесурса] = СтрокаДанныхПервичногоРегистра[ОписаниеРесурса];
			СтруктураДанныхТекущейСтроки["ИспользованиеРесурса" + ОписаниеРесурса] = СтрокаДанныхПервичногоРегистра["ИспользованиеРесурса" + ОписаниеРесурса];	
			
			Если СтрокаДанныхПервичногоРегистра["ИспользованиеРесурса" + ОписаниеРесурса] = Перечисления.ЗначениеРесурсаРегистровСостоянийСотрудника.Установлено Тогда
				СтруктураДанныхТекущейСтроки["ЗарегистрированоЗначение" + ОписаниеРесурса] = Истина;	
			КонецЕсли;	
		КонецЕсли;	
		
	КонецЦикла;	
	
	Если ПродолжатьДействиеТекущегоСостояния(ИтоговыеДанные, СтруктураДанныхТекущейСтроки, ОписаниеРегистра) Тогда
		ДобавленнаяСтрока = ИтоговыеДанные[ИтоговыеДанные.Количество() - 1];
		ДобавленнаяСтрока.Окончание = '00010101';
	ИначеЕсли ЗначенияРесурсовСостоянияУстановлена(СтруктураДанныхТекущейСтроки, ОписаниеРегистра) Тогда
		ДобавленнаяСтрока = ИтоговыеДанные.Добавить();
		ЗаполнитьЗначенияСвойств(ДобавленнаяСтрока, СтруктураДанныхТекущейСтроки);
	КонецЕсли;
	
	Возврат ДобавленнаяСтрока;
	
КонецФункции

Функция ПродолжатьДействиеТекущегоСостояния(ИтоговыеДанные, ДобавляемыеДанные, ОписаниеРегистра)
	Если ИтоговыеДанные.Количество() = 0 Тогда 
		Возврат Ложь;
	КонецЕсли;
	
	ТекущаяСтрока = ИтоговыеДанные[ИтоговыеДанные.Количество() - 1];
	
	// Обрабатываем ситуацию когда две записи приходятся на одну дату.
	Если ТекущаяСтрока.Окончание <> ДобавляемыеДанные.Начало - 86400 Тогда	
		Возврат Ложь;
	КонецЕсли;	
	
	Для Каждого ОписаниеРесурса Из ОписаниеРегистра.Ресурсы Цикл
		Если ТекущаяСтрока[ОписаниеРесурса] <> ДобавляемыеДанные[ОписаниеРесурса]
			Или ТекущаяСтрока["ИспользованиеРесурса" + ОписаниеРесурса] <> ДобавляемыеДанные["ИспользованиеРесурса" + ОписаниеРесурса] Тогда
			
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции	

Функция ЗначенияРесурсовСостоянияУстановлена(ДобавляемыеДанные, ОписаниеРегистра)
	
	Для Каждого ОписаниеРесурса Из ОписаниеРегистра.Ресурсы Цикл
		Если ЗначениеРесурсаЗаписиСостоянияУстановлено(ДобавляемыеДанные, ОписаниеРесурса) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
КонецФункции

Функция ЗначениеРесурсаЗаписиСостоянияУстановлено(ДанныеЗаписи, ИмяРесурса)
	Если ДанныеЗаписи["ИспользованиеРесурса" + ИмяРесурса] = Перечисления.ЗначениеРесурсаРегистровСостоянийСотрудника.НеУстановлено
		Или ДанныеЗаписи["ИспользованиеРесурса" + ИмяРесурса].Пустая() Тогда
		
		Возврат Ложь;
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции	

Функция ДатаДействияРесурсаБольше(ДатаДействияРесурса, СравниваемаяДата)
	Если ДатаДействияРесурса = '00010101' Тогда
		Возврат Истина;
	ИначеЕсли СравниваемаяДата = '00010101' Тогда
		Возврат Ложь;
	Иначе
		Возврат ДатаДействияРесурса > СравниваемаяДата;
	КонецЕсли;
КонецФункции

Функция ДатаДействияРесурсаБольшеИлиРавна(ДатаДействияРесурса, СравниваемаяДата)
	Если ДатаДействияРесурса = СравниваемаяДата Тогда
		Возврат Истина;
	Иначе
		Возврат ДатаДействияРесурсаБольше(ДатаДействияРесурса, СравниваемаяДата);
	КонецЕсли;	
КонецФункции

Функция ТаблицаРассчитанныхПериодовСостояний(ОписаниеРегистра)
	Таблица = Новый ТаблицаЗначений;
	Таблица.Колонки.Добавить("Начало");
	Таблица.Колонки.Добавить("Окончание");
	
	Для Каждого ИзмерениеРегистра Из ОписаниеРегистра.Измерения Цикл
		Таблица.Колонки.Добавить(ИзмерениеРегистра);		
	КонецЦикла;	
	
	Для Каждого РесурсРегистра Из ОписаниеРегистра.Ресурсы Цикл
		Таблица.Колонки.Добавить(РесурсРегистра);
		Таблица.Колонки.Добавить("ИспользованиеРесурса" + РесурсРегистра);
		Таблица.Колонки.Добавить("ЗарегистрированоЗначение" + РесурсРегистра);
	КонецЦикла;	
	
	Возврат Таблица;
	
КонецФункции	

Функция СтруктураЗаписиРассчитанныхПериодовСостояний(ОписаниеРегистра)
	СтруктураЗаписи = Новый Структура;
	СтруктураЗаписи.Вставить("Начало");
	СтруктураЗаписи.Вставить("ДатаНачалаСобытия");
	СтруктураЗаписи.Вставить("Окончание");
	СтруктураЗаписи.Вставить("ДействуетДо");
	СтруктураЗаписи.Вставить("Приоритет");
	
	Для Каждого ИзмерениеРегистра Из ОписаниеРегистра.Измерения Цикл
		СтруктураЗаписи.Вставить(ИзмерениеРегистра);
	КонецЦикла;	
 	
	Для Каждого РесурсРегистра Из ОписаниеРегистра.Ресурсы Цикл
		СтруктураЗаписи.Вставить(РесурсРегистра);
		СтруктураЗаписи.Вставить("ИспользованиеРесурса" + РесурсРегистра);
		СтруктураЗаписи.Вставить("ЗарегистрированоЗначение" + РесурсРегистра);
	КонецЦикла;	
		
	Возврат СтруктураЗаписи;	
КонецФункции	

#КонецОбласти

#КонецОбласти

#КонецОбласти

